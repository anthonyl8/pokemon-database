This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
database/ability.csv
database/badge.csv
database/create_pokemon_db.sql
database/csv_to_table_images.py
database/egg_group.csv
database/export_database.sql
database/gym_leader_1.csv
database/gym_leader_2.csv
database/insert_data.sql
database/item_1.csv
database/item_2.csv
database/location.csv
database/move.csv
database/player_owns_badge.csv
database/player.csv
database/pokemon_1.csv
database/pokemon_2.csv
database/pokemon_3.csv
database/pokemon_has_learned_move.csv
database/reset.sql
database/setup_all.sql
database/species_belongs_to_egg_group.csv
database/species_can_have_ability.csv
database/species_can_learn_move.csv
database/species_evolves_into.csv
database/species_has_type.csv
database/species_located_in.csv
database/species.csv
database/trainer.csv
database/type.csv
frontend/.env
frontend/.gitignore
frontend/appController.js
frontend/appService.js
frontend/package.json
frontend/public/index.html
frontend/public/scripts.js
frontend/public/styles.css
frontend/remote-start.sh
frontend/scripts/mac/db-tunnel.sh
frontend/scripts/mac/instantclient-setup.sh
frontend/scripts/mac/server-tunnel.sh
frontend/scripts/win/db-tunnel.cmd
frontend/scripts/win/instantclient-setup.cmd
frontend/scripts/win/server-tunnel.cmd
frontend/server.js
frontend/utils/envUtil.js
queries.txt
README.md
README.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="database/csv_to_table_images.py">
import pandas as pd
import matplotlib.pyplot as plt
import os
import glob
import re

def fix_malformed_csv(csv_file):
    """
    Fix malformed CSV files where data is split across lines
    """
    try:
        with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()
        
        # Clean up lines and remove extra whitespace
        cleaned_lines = []
        current_line = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # If line starts with a number (likely a new record) and we have a current line
            if re.match(r'^\s*\d+,', line) and current_line:
                cleaned_lines.append(current_line)
                current_line = line
            elif current_line:
                # Continue the current line (probably a description that was split)
                current_line += " " + line.replace('"', '')
            else:
                current_line = line
        
        # Add the last line
        if current_line:
            cleaned_lines.append(current_line)
        
        return cleaned_lines
        
    except Exception as e:
        print(f"Error fixing {csv_file}: {e}")
        return None

def create_table_image(csv_file, max_rows=20, max_cols=10):
    """
    Create a professional-looking table image from a CSV file
    """
    print(f"Processing {csv_file}...")
    
    # Try to read CSV normally first
    try:
        df = pd.read_csv(csv_file)
    except:
        # If normal reading fails, try to fix the malformed CSV
        print(f"  Normal CSV reading failed, attempting to fix malformed CSV...")
        fixed_lines = fix_malformed_csv(csv_file)
        
        if not fixed_lines:
            print(f"  Could not fix {csv_file}")
            return
            
        # Create a temporary fixed file
        temp_file = csv_file.replace('.csv', '_temp.csv')
        with open(temp_file, 'w') as f:
            f.write('\n'.join(fixed_lines))
        
        try:
            df = pd.read_csv(temp_file)
            os.remove(temp_file)  # Clean up temp file
        except Exception as e:
            print(f"  Still couldn't read {csv_file} after fixing: {e}")
            if os.path.exists(temp_file):
                os.remove(temp_file)
            return
    
    print(f"  Successfully loaded: {len(df)} rows, {len(df.columns)} columns")
    
    # Get table name from filename
    table_name = os.path.splitext(os.path.basename(csv_file))[0].upper().replace('_', ' ')
    
    # Handle empty dataframes
    if df.empty:
        print(f"  Warning: {csv_file} is empty")
        return
    
    # Limit rows and columns for readability
    original_rows = len(df)
    original_cols = len(df.columns)
    
    if len(df) > max_rows:
        df = df.head(max_rows)
        truncated_rows = True
    else:
        truncated_rows = False
        
    if len(df.columns) > max_cols:
        df = df.iloc[:, :max_cols]
        truncated_cols = True
    else:
        truncated_cols = False
    
    # Clean up data for display
    df = df.fillna('NULL')
    
    # Truncate long text in cells and handle encoding issues
    for col in df.columns:
        if df[col].dtype == 'object':
            df[col] = df[col].astype(str).apply(lambda x: 
                x.replace('??', 'é')  # Fix encoding issues
                 .replace('\n', ' ')   # Remove newlines
                 .replace('\r', ' ')   # Remove carriage returns
                 .strip()              # Remove extra whitespace
            )
            # Truncate very long text
            df[col] = df[col].apply(lambda x: x[:60] + '...' if len(x) > 60 else x)
    
    # Calculate figure size based on content
    n_rows, n_cols = df.shape
    fig_width = max(12, min(24, n_cols * 2.5))
    fig_height = max(6, min(16, (n_rows + 2) * 0.5))
    
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(fig_width, fig_height))
    ax.axis('off')
    
    # Create the table
    table_data = [df.columns.tolist()] + df.values.tolist()
    
    # Create table
    table = ax.table(
        cellText=table_data[1:],  # Data rows
        colLabels=table_data[0],  # Header row
        cellLoc='left',           # Left align for better readability
        loc='center',
        bbox=[0, 0, 1, 1]
    )
    
    # Style the table
    table.auto_set_font_size(False)
    table.set_fontsize(8)
    table.scale(1, 1.8)
    
    # Header styling
    for i in range(len(df.columns)):
        table[(0, i)].set_facecolor('#2E4A87')
        table[(0, i)].set_text_props(weight='bold', color='white')
        table[(0, i)].set_height(0.15)
    
    # Alternate row colors and adjust cell alignment
    for i in range(1, len(table_data)):
        for j in range(len(df.columns)):
            cell = table[(i, j)]
            
            if i % 2 == 0:
                cell.set_facecolor('#F8F9FA')
            else:
                cell.set_facecolor('#FFFFFF')
            
            cell.set_height(0.12)
            
            # Left align text cells, center align numbers
            if isinstance(table_data[i][j], (int, float)):
                cell.set_text_props(ha='center')
            else:
                cell.set_text_props(ha='left')
    
    # Add title with better formatting
    title = f"{table_name} TABLE"
    subtitle = f"({len(df)} rows shown"
    if truncated_rows:
        subtitle = f"({len(df)} of {original_rows} rows shown"
    if truncated_cols:
        subtitle += f", {len(df.columns)} of {original_cols} columns shown"
    subtitle += ")"
    
    plt.suptitle(f"{title}\n{subtitle}", fontsize=14, fontweight='bold', y=0.95)
    
    # Adjust layout
    plt.tight_layout()
    plt.subplots_adjust(top=0.88)
    
    # Save the image
    output_file = f"{os.path.splitext(csv_file)[0]}_table.png"
    plt.savefig(output_file, dpi=300, bbox_inches='tight', 
                facecolor='white', edgecolor='none', pad_inches=0.2)
    plt.close()
    
    print(f"  ✓ Created {output_file}")

def create_overview_image(csv_files):
    """
    Create an overview image showing all table names and row counts
    """
    print("Creating database overview...")
    table_info = []
    
    for csv_file in csv_files:
        try:
            # Try normal reading first
            try:
                df = pd.read_csv(csv_file)
            except:
                # Try fixing malformed CSV
                fixed_lines = fix_malformed_csv(csv_file)
                if fixed_lines:
                    temp_file = csv_file.replace('.csv', '_temp.csv')
                    with open(temp_file, 'w') as f:
                        f.write('\n'.join(fixed_lines))
                    df = pd.read_csv(temp_file)
                    os.remove(temp_file)
                else:
                    continue
            
            table_name = os.path.splitext(os.path.basename(csv_file))[0].upper()
            table_info.append([table_name, len(df), len(df.columns)])
        except Exception as e:
            print(f"  Could not process {csv_file} for overview: {e}")
            continue
    
    if not table_info:
        print("  No valid tables found for overview")
        return
    
    # Create overview table
    overview_df = pd.DataFrame(table_info, columns=['TABLE NAME', 'ROWS', 'COLUMNS'])
    overview_df = overview_df.sort_values('TABLE NAME')
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, max(8, len(table_info) * 0.4)))
    ax.axis('off')
    
    # Create table
    table = ax.table(
        cellText=overview_df.values.tolist(),
        colLabels=overview_df.columns.tolist(),
        cellLoc='center',
        loc='center',
        bbox=[0, 0, 1, 1]
    )
    
    # Style the overview table
    table.auto_set_font_size(False)
    table.set_fontsize(12)
    table.scale(1, 2)
    
    # Header styling
    for i in range(len(overview_df.columns)):
        table[(0, i)].set_facecolor('#1F4E79')
        table[(0, i)].set_text_props(weight='bold', color='white')
    
    # Alternate row colors
    for i in range(1, len(overview_df) + 1):
        for j in range(len(overview_df.columns)):
            if i % 2 == 0:
                table[(i, j)].set_facecolor('#E8F2FF')
            else:
                table[(i, j)].set_facecolor('#FFFFFF')
    
    plt.suptitle('POKEMON DATABASE - TABLE OVERVIEW', fontsize=16, fontweight='bold')
    plt.tight_layout()
    
    plt.savefig('database_overview.png', dpi=300, bbox_inches='tight', 
                facecolor='white', edgecolor='none')
    plt.close()
    
    print("  ✓ Created database_overview.png")

def main():
    """
    Main function to process all CSV files in current directory
    """
    print("Pokemon Database CSV to Image Converter")
    print("=" * 50)
    
    # Find all CSV files in current directory
    csv_files = glob.glob("*.csv")
    
    if not csv_files:
        print("No CSV files found in current directory!")
        print("Make sure you've exported your database tables to CSV first.")
        return
    
    print(f"Found {len(csv_files)} CSV files:")
    for csv_file in sorted(csv_files):
        print(f"  - {csv_file}")
    print()
    
    # Create overview first
    create_overview_image(csv_files)
    print()
    
    # Process each CSV file
    success_count = 0
    for csv_file in sorted(csv_files):
        try:
            create_table_image(csv_file)
            success_count += 1
        except Exception as e:
            print(f"  ✗ Error processing {csv_file}: {e}")
    
    print(f"\n{'='*50}")
    print(f"✓ {success_count} table images created successfully!")
    print("✓ Files saved as: [filename]_table.png")
    print("✓ Overview saved as: database_overview.png")
    
    if success_count < len(csv_files):
        print(f"\n⚠ {len(csv_files) - success_count} files had issues.")
        print("Consider re-exporting with the fixed SQL script if problems persist.")

if __name__ == "__main__":
    main()
</file>

<file path="README.txt">
No extra information
</file>

<file path=".gitignore">
# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Database backups
database/backup/*.dmp
database/backup/*.sql

# Application specific
app/config/database_local.php
*.log

# Temporary files
*.tmp
temp/
</file>

<file path="frontend/.env">
# TODO: Edit the values below this line according to the given placeholders
# Replace 'ora_YOUR-CWL-USERNAME' with "ora_" (no quotation marks) followed by your CWL username.
ORACLE_USER=ora_gstracha
# Replace 'YOUR-STUDENT-NUMBER' with your actual student number.
ORACLE_PASS=a37275377


#Adjust the PORT if needed (e.g., if you encounter a "port already occupied" error)
PORT=65535

# -------------- The three lines below should be left unaltered --------------
ORACLE_HOST=dbhost.students.cs.ubc.ca
ORACLE_PORT=1522
ORACLE_DBNAME=stu
</file>

<file path="frontend/.gitignore">
# Dependency directories
node_modules/

# Logs
*.log

# dotenv environment variable files
#.env

# IDEs and editors
.vscode/
.idea/

# Mac files
.DS_Store

# Windows image file caches
Thumbs.db

# Windows shortcuts
*.lnk
</file>

<file path="frontend/package.json">
{
  "name": "node_demo_project",
  "version": "1.0.0",
  "description": "The sample Node.js project for CPSC304.",
  "main": "server.js",
  "keywords": [],
  "author": {
    "name": "Zoe Yuan"
  },
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.3",
    "oracledb": "^5.2.0"
  }
}
</file>

<file path="frontend/scripts/mac/db-tunnel.sh">
#!/bin/bash

# Change to the directory where the script is located
cd "$(dirname "$0")"

# File path
ENV_FILE_PATH="../../.env"

# Define a range
START=50000
END=55000

# Variables to track if ORACLE_HOST and ORACLE_PORT are found
found_host=0
found_port=0

# Check if ORACLE_HOST and ORACLE_PORT variables exist in the .env file
if grep -q '^ORACLE_HOST=' $ENV_FILE_PATH; then
    found_host=1
fi
if grep -q '^ORACLE_PORT=' $ENV_FILE_PATH; then
    found_port=1
fi

# Check if ORACLE_HOST and ORACLE_PORT were found, if not, exit 1
if [[ $found_host -eq 0 ]] || [[ $found_port -eq 0 ]]; then
    echo "ERROR: ORACLE_HOST or ORACLE_PORT not found in the .env file."
    exit 1
fi

# Loop through the range and check if the port is in use
for port in $(seq $START $END); do
    # Use lsof to check if the port is in use
    if ! lsof -i :$port > /dev/null; then
        perl -i -pe "s/^ORACLE_HOST=.*/ORACLE_HOST=localhost/" $ENV_FILE_PATH
        perl -i -pe "s/^ORACLE_PORT=.*/ORACLE_PORT=$port/" $ENV_FILE_PATH
        chosen_port=$port
        break
    fi
done

if [[ -z "$chosen_port" ]]; then
    echo "No free port found in range 50000-60000."
    exit 1
fi

echo "Building SSH tunnel on port $chosen_port to your oracle database..."

read -p "Enter your CWL name: " cwl_name

exec ssh -L $chosen_port:dbhost.students.cs.ubc.ca:1522 $cwl_name@remote.students.cs.ubc.ca
</file>

<file path="frontend/scripts/mac/instantclient-setup.sh">
#!/bin/bash

# Change to the directory where the script is located
cd "$(dirname "$0")"

echo "Please enter the absolute path to the Oracle Instant Client directory:"
read oraclePath

# Construct the local start script
(
echo '#!/bin/bash'
echo
echo '# Change to the directory where the script is located'
echo 'cd "$(dirname "$0")"'
echo
echo "# Configure the oracle instant client env variable"
echo "export DYLD_LIBRARY_PATH=$oraclePath:\$DYLD_LIBRARY_PATH"
echo
echo "# Start Node application"
echo "exec node server.js"
) > ../../local-start.sh

# Change the permissions of the script to make it executable
chmod +x ../../local-start.sh
echo "--------------------------------------------------------------------------"
echo "Setup complete. Run 'sh local-start.sh' in your project folder to start your Node.js application."
echo "--------------------------------------------------------------------------"

exit 0
</file>

<file path="frontend/scripts/mac/server-tunnel.sh">
#!/bin/bash

# Take input from the user
read -p "Enter your remote Node starting port number: " destination_port

# Define a range
START=55001
END=60000

# Check if the provided port is free
if ! lsof -Pi :$destination_port -sTCP:LISTEN -t >/dev/null ; then
    echo "Local port $destination_port is available."
    chosen_port=$destination_port
else
    # If not free, find a port in the range 50000-60000
    for port in $(seq $START $END); do
        if ! lsof -Pi :$port -sTCP:LISTEN -t >/dev/null ; then
            echo "Local port $port is available."
            chosen_port=$port
            break
        fi
    done
fi

# No port is found in the range
if [[ -z "$chosen_port" ]]; then
    echo "No free port found in range $START-$END."
    exit 1
fi

echo "--------------------------------------------------------------------------"
echo "        You will be able to access your application at: "
echo "        http://localhost:$chosen_port"
echo "        after completing the steps below..."
echo "--------------------------------------------------------------------------"


echo "Building SSH tunnel using port $chosen_port..."

read -p "Enter your CWL name: " cwl_name

# Build the SSH tunnel
exec ssh -L $chosen_port:localhost:$destination_port $cwl_name@remote.students.cs.ubc.ca
</file>

<file path="frontend/scripts/win/db-tunnel.cmd">
@echo off
setlocal enabledelayedexpansion

:: Change to the directory where the script is located
cd %~dp0

:: File path
set ENV_FILE_PATH=..\..\.env
set TMP_FILE_PATH=temp.env

:: Define a range
set START=50000
set END=55000
set chosen_port=

:: Variables to track if ORACLE_HOST and ORACLE_PORT are found
set found_host=0
set found_port=0


:: Delete temp file if it already exists
if exist %TMP_FILE_PATH% (
    del %TMP_FILE_PATH% >nul
)

:: Check if ORACLE_HOST and ORACLE_PORT variables exist in the .env file
findstr /B "ORACLE_HOST=" %ENV_FILE_PATH% >nul && SET found_host=1
findstr /B "ORACLE_PORT=" %ENV_FILE_PATH% >nul && SET found_port=1

:: Check if ORACLE_HOST and ORACLE_PORT were found, if not, exit 1
if not !found_host!==1 (
    goto handleError
)
if not !found_port!==1 (
    goto handleError
)
goto continue

:handleError
    echo "ERROR: ORACLE_HOST or ORACLE_PORT not found in the .env file."
    exit /b 1

:continue

:: Loop through the range and check if the port is in use
for /l %%i in (%START%,1,%END%) do (
    netstat -an | find "%%i" >nul
    if errorlevel 1 (
        :: Port is available
        set chosen_port=%%i
        goto foundPort
    )
)

:foundPort
if "%chosen_port%"=="" (
    echo No free port found in range 50000-55000.
    exit /b 1
)

:: Replace ORACLE_HOST and ORACLE_PORT in the .env file
for /F "tokens=1,* delims=:" %%l in ('findstr /n "^" %ENV_FILE_PATH%') do (
    set "line=%%m"
    if "%%m"=="" (
        echo. >> %TMP_FILE_PATH%
    ) else if "!line:~0,12!"=="ORACLE_HOST=" (
        echo ORACLE_HOST=localhost >> %TMP_FILE_PATH%
    ) else if "!line:~0,12!"=="ORACLE_PORT=" (
        echo ORACLE_PORT=%chosen_port% >> %TMP_FILE_PATH%
    ) else (
        echo !line! >> %TMP_FILE_PATH%
    )
)

:: Move temp file back to original .env file
move /Y %TMP_FILE_PATH% %ENV_FILE_PATH% >nul

:: Delete the temporary file
del %TMP_FILE_PATH% >nul

echo Building SSH tunnel on port %chosen_port% to your oracle database...

set /p cwl_name=Enter your CWL name:

:: Try to find ssh in the system's PATH
where /q ssh
if errorlevel 0 (
    ssh -L !chosen_port!:dbhost.students.cs.ubc.ca:1522 !cwl_name!@remote.students.cs.ubc.ca
    goto :end
)

:: Check for Plink availability and run the appropriate command
if exist "%ProgramFiles%"\PuTTY\plink.exe (
    "%ProgramFiles%"\PuTTY\plink.exe -L !chosen_port!:dbhost.students.cs.ubc.ca:1522 !cwl_name!@remote.students.cs.ubc.ca
    goto :end
) else if exist "%ProgramFiles(x86)%"\PuTTY\plink.exe (
    "%ProgramFiles(x86)%"\PuTTY\plink.exe -L !chosen_port!:dbhost.students.cs.ubc.ca:1522 !cwl_name!@remote.students.cs.ubc.ca
    goto :end
) else (
    echo Neither SSH nor PuTTY's Plink was found on your system.
    echo If you have SSH or PuTTY installed, please ensure they are in the expected paths or add them to your PATH variable.
    echo Otherwise, you might need to manually set up the SSH tunnel using your preferred SSH client.
    pause
    exit /b 1
)

:end
exit /b 0
</file>

<file path="frontend/scripts/win/instantclient-setup.cmd">
@echo off
cd %~dp0
echo Please enter the absolute path to the Oracle Instant Client directory:
set /p oraclePath=

:: Construct the local start script
(
echo @echo off
echo.
echo :: Change to the directory where the script is located
echo cd %%~dp0
echo.
echo :: Configure the oracle instant client env variable
echo set PATH=%%PATH%%;"%oraclePath%"
echo.
echo :: Start Node application
echo node server.js
echo.
echo exit /b 0
) > ..\..\local-start.cmd

echo --------------------------------------------------------------------------
echo Setup complete. Run 'local-start.cmd' in your project folder to start your Node.js application.
echo --------------------------------------------------------------------------
pause
</file>

<file path="frontend/scripts/win/server-tunnel.cmd">
@echo off
setlocal enabledelayedexpansion

:: Take input from the user
set /p destination_port="Enter your remote Node starting port number: "

set START=55001
set END=60000

:: Check if the provided port is free
netstat -an | find ":%destination_port%" > nul
if errorlevel 1 (
    echo Port %destination_port% is available.
    set chosen_port=%destination_port%
) else (
    :: If not free, find a port in the range START-END
    for /l %%i in (%START%,1,%END%) do (
        netstat -an | find "%%i" > nul
        if errorlevel 1 (
            echo Port %%i is available.
            set chosen_port=%%i
            goto portFound
        )
    )
)

:portFound
:: If no port is found in the range, exit 1
if not defined chosen_port (
    echo No free port found in range !START!-!END!.
    exit /b 1
)

echo --------------------------------------------------------------------------
echo         You will be able to access your application at:
echo         http://localhost:!chosen_port!
echo         after completing the steps below...
echo --------------------------------------------------------------------------


:: Build the SSH tunnel using the chosen port
echo Building SSH tunnel using port !chosen_port!...
set /p cwl_name="Enter your CWL name: "


:: Try to find ssh in the system's PATH
where /q ssh
if errorlevel 0 (
    ssh -L !chosen_port!:localhost:!destination_port! !cwl_name!@remote.students.cs.ubc.ca
    goto :end
)

:: Check for Plink availability and run the appropriate command
if exist "%ProgramFiles%"\PuTTY\plink.exe (
    "%ProgramFiles%"\PuTTY\plink.exe -L !chosen_port!:localhost:!destination_port! !cwl_name!@remote.students.cs.ubc.ca
    goto :end
) else if exist "%ProgramFiles(x86)%"\PuTTY\plink.exe (
    "%ProgramFiles(x86)%"\PuTTY\plink.exe -L !chosen_port!:localhost:!destination_port! !cwl_name!@remote.students.cs.ubc.ca
    goto :end
) else (
    echo Neither SSH nor PuTTY's Plink was found on your system.
    echo If you have SSH or PuTTY installed, please ensure they are in the expected paths or add them to your PATH variable.
    echo Otherwise, you might need to manually set up the SSH tunnel using your preferred SSH client.
    pause
    exit /b 1
)

:end
exit /b 0
</file>

<file path="frontend/server.js">
const express = require('express');
const appController = require('./appController');

// Load environment variables from .env file
// Ensure your .env file has the required database credentials.
const loadEnvFile = require('./utils/envUtil');
const envVariables = loadEnvFile('./.env');

const app = express();
const PORT = envVariables.PORT || 65534;  // Adjust the PORT if needed (e.g., if you encounter a "port already occupied" error)

// Middleware setup
app.use(express.static('public'));  // Serve static files from the 'public' directory
app.use(express.json());             // Parse incoming JSON payloads

// If you prefer some other file as default page other than 'index.html',
//      you can adjust and use the bellow line of code to
//      route to send 'DEFAULT_FILE_NAME.html' as default for root URL
// app.get('/', (req, res) => {
//     res.sendFile(__dirname + '/public/DEFAULT_FILE_NAME.html');
// });


// mount the router
app.use('/', appController);


// ----------------------------------------------------------
// Starting the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
});
</file>

<file path="frontend/utils/envUtil.js">
const fs = require('fs');

function loadEnvFile(filePath) {
    if (fs.existsSync(filePath)) {
        const envFile = fs.readFileSync(filePath, 'utf8');

        const envVars = envFile.split('\n').reduce((acc, line) => {
            const [key, value] = line.split('=');
            acc[key] = value;
            return acc;
        }, {});

        return envVars;
    } else {
        console.error(`.env file not found at ${filePath}`);
        return {};
    }
}

module.exports = loadEnvFile;
</file>

<file path="database/ability.csv">
ABILITY_ID,NAME,DESCRIPTION
2,Static,"Contact with the Pok??mon may cause paralysis."
4,Overgrow,"Powers up Grass-type moves when the Pok??mon's HP is low."
5,Blaze,"Powers up Fire-type moves when the Pok??mon's HP is low."
6,Torrent,"Powers up Water-type moves when the Pok??mon's HP is low."
8,Chlorophyll,"Boosts the Pok??mon's Speed stat in harsh sunlight."
9,Solar Power,"Boosts the Sp. Atk stat in harsh sunlight, but HP decreases every turn."
10,Rain Dish,"The Pok??mon gradually regains HP in rain."
11,Lightning Rod,"Draws in all Electric-type moves to boost its Sp. Atk stat."
</file>

<file path="database/badge.csv">
BADGE_INDEX,NAME
1,Boulder Badge
2,Cascade Badge
3,Thunder Badge
4,Rainbow Badge
5,Soul Badge
6,Marsh Badge
</file>

<file path="database/egg_group.csv">
EGG_GROUP_ID,NAME,DESCRIPTION
1,Mineral,"Pokemon in this group are inorganic in nature"
2,Amorphous,"Pokemon in this group are amorphous, having no definite form"
3,Grass,"Pokemon in this group are plantlike in appearance"
4,Water 3,"Pokemon in this group resemble aquatic invertebrates"
5,Water 2,"Pokemon in this group are piscine (fishlike) in appearance"
6,Water 1,"Pokemon in this group are amphibious in nature"
7,Bug,"Pokemon in this group are insectoid (bug-like) in appearance"
8,Dragon,"Pokemon in this group are reptilian or draconic in appearance"
9,Flying,"Pokemon in this group are avian (birdlike) in appearance"
10,Field,"The largest group, Pokemon here are terrestrial in nature"
11,Human-Like,"Pokemon in this group are fully bipedal humanoids"
12,Fairy,"Pokemon in this group are petite and considered very cute"
13,Monster,"Pokemon in this group are saurian/kaiju-like in appearance and nature"
14,Ditto,"Ditto is the only Pokemon in this group, capable of breeding with most others"
15,No Eggs Discovered,"Pokemon in this group are unable to breed"
</file>

<file path="database/export_database.sql">
SET PAGESIZE 0
SET LINESIZE 2000
SET FEEDBACK OFF
SET HEADING OFF
SET TRIMSPOOL ON
SET TRIMOUT ON
SET WRAP OFF

SPOOL location.csv
SELECT 'NAME,CLIMATE,TERRAIN_TYPE' FROM dual;
SELECT name||','||climate||','||terrain_type FROM Location ORDER BY name;
SPOOL OFF

SPOOL type.csv
SELECT 'NAME,COLOUR' FROM dual;
SELECT name||','||colour FROM Type ORDER BY name;
SPOOL OFF

SPOOL badge.csv
SELECT 'BADGE_INDEX,NAME' FROM dual;
SELECT badge_index||','||name FROM Badge ORDER BY badge_index;
SPOOL OFF

SPOOL ability.csv
SELECT 'ABILITY_ID,NAME,DESCRIPTION' FROM dual;
SELECT ability_id||','||name||',"'||REPLACE(description,'"','""')||'"' FROM Ability ORDER BY ability_id;
SPOOL OFF

SPOOL species.csv
SELECT 'POKEDEX,NAME,DESCRIPTION' FROM dual;
SELECT pokedex||','||name||',"'||REPLACE(description,'"','""')||'"' FROM Species ORDER BY pokedex;
SPOOL OFF

SPOOL egg_group.csv
SELECT 'EGG_GROUP_ID,NAME,DESCRIPTION' FROM dual;
SELECT egg_group_id||','||name||',"'||REPLACE(description,'"','""')||'"' FROM Egg_Group ORDER BY egg_group_id;
SPOOL OFF

SPOOL move.csv
SELECT 'MOVE_ID,NAME,POWER,PP,ACCURACY,DESCRIPTION,TYPE_NAME' FROM dual;
SELECT move_id||','||name||','||power||','||pp||','||accuracy||',"'||REPLACE(description,'"','""')||'",'||type_name FROM Move ORDER BY move_id;
SPOOL OFF

SPOOL pokemon_2.csv
SELECT 'NATURE,STAT_INCREASED,STAT_DECREASED' FROM dual;
SELECT nature||','||stat_increased||','||stat_decreased FROM Pokemon_2 ORDER BY nature;
SPOOL OFF

SPOOL pokemon_3.csv
SELECT 'TOTAL_XP,POKEMON_LEVEL' FROM dual;
SELECT total_XP||','||pokemon_level FROM Pokemon_3 ORDER BY pokemon_level;
SPOOL OFF

SPOOL item_2.csv
SELECT 'PRICE,RARITY' FROM dual;
SELECT price||','||rarity FROM Item_2 ORDER BY price;
SPOOL OFF

SPOOL gym_leader_2.csv
SELECT 'DIFFICULTY,CASH_REWARD' FROM dual;
SELECT difficulty||','||cash_reward FROM Gym_Leader_2 ORDER BY difficulty;
SPOOL OFF

SPOOL trainer.csv
SELECT 'TRAINER_ID,NAME,LOCATION_NAME' FROM dual;
SELECT trainer_id||','||name||','||NVL(location_name,'NULL') FROM Trainer ORDER BY trainer_id;
SPOOL OFF

SPOOL item_1.csv
SELECT 'NAME,DESCRIPTION,PRICE,LOCATION_NAME' FROM dual;
SELECT name||',"'||REPLACE(description,'"','""')||'",'||price||','||NVL(location_name,'NULL') FROM Item_1 ORDER BY name;
SPOOL OFF

SPOOL pokemon_1.csv
SELECT 'POKEDEX,POKEMON_ID,NAME,TOTAL_XP,NATURE,HP_IV,ATTACK_IV,DEFENSE_IV,SPEED_IV,ABILITY_ID,TRAINER_ID' FROM dual;
SELECT pokedex||','||pokemon_id||','||name||','||total_XP||','||nature||','||HP_IV||','||attack_IV||','||defense_IV||','||speed_IV||','||ability_id||','||NVL(trainer_id,0) FROM Pokemon_1 ORDER BY pokedex, pokemon_id;
SPOOL OFF

SPOOL gym_leader_1.csv
SELECT 'TRAINER_ID,DIFFICULTY,SPECIALTY_TYPE_NAME,BADGE_INDEX' FROM dual;
SELECT trainer_id||','||difficulty||','||specialty_type_name||','||badge_index FROM Gym_Leader_1 ORDER BY trainer_id;
SPOOL OFF

SPOOL player.csv
SELECT 'TRAINER_ID,MONEY' FROM dual;
SELECT trainer_id||','||money FROM Player ORDER BY trainer_id;
SPOOL OFF

SPOOL species_evolves_into.csv
SELECT 'OLD_POKEDEX,NEW_POKEDEX,EVOLUTION_LEVEL' FROM dual;
SELECT old_pokedex||','||new_pokedex||','||NVL(evolution_level,0) FROM Species_Evolves_Into ORDER BY old_pokedex;
SPOOL OFF

SPOOL pokemon_has_learned_move.csv
SELECT 'POKEDEX,POKEMON_ID,MOVE_ID' FROM dual;
SELECT pokedex||','||pokemon_id||','||move_id FROM Pokemon_Has_Learned_Move ORDER BY pokedex, pokemon_id, move_id;
SPOOL OFF

SPOOL species_has_type.csv
SELECT 'POKEDEX,TYPE_NAME' FROM dual;
SELECT pokedex||','||type_name FROM Species_Has_Type ORDER BY pokedex, type_name;
SPOOL OFF

SPOOL species_can_learn_move.csv
SELECT 'POKEDEX,MOVE_ID' FROM dual;
SELECT pokedex||','||move_id FROM Species_Can_Learn_Move ORDER BY pokedex, move_id;
SPOOL OFF

SPOOL species_can_have_ability.csv
SELECT 'POKEDEX,ABILITY_ID' FROM dual;
SELECT pokedex||','||ability_id FROM Species_Can_Have_Ability ORDER BY pokedex, ability_id;
SPOOL OFF

SPOOL species_located_in.csv
SELECT 'POKEDEX,LOCATION_NAME' FROM dual;
SELECT pokedex||','||location_name FROM Species_Located_In ORDER BY pokedex, location_name;
SPOOL OFF

SPOOL species_belongs_to_egg_group.csv
SELECT 'POKEDEX,EGG_GROUP_ID' FROM dual;
SELECT pokedex||','||egg_group_id FROM Species_Belongs_To_Egg_Group ORDER BY pokedex, egg_group_id;
SPOOL OFF

SPOOL player_owns_badge.csv
SELECT 'TRAINER_ID,BADGE_INDEX' FROM dual;
SELECT trainer_id||','||badge_index FROM Player_Owns_Badge ORDER BY trainer_id, badge_index;
SPOOL OFF

SET PAGESIZE 14
SET FEEDBACK ON
SET HEADING ON

PROMPT All tables exported to properly formatted CSV files!
</file>

<file path="database/gym_leader_1.csv">
TRAINER_ID,DIFFICULTY,SPECIALTY_TYPE_NAME,BADGE_INDEX
3,1,Rock,1
4,2,Water,2
5,3,Electric,3
6,4,Grass,4
7,5,Poison,5
8,5,Psychic,6
</file>

<file path="database/gym_leader_2.csv">
DIFFICULTY,CASH_REWARD
1,1000
2,2000
3,3000
4,5000
5,10000
</file>

<file path="database/item_1.csv">
NAME,DESCRIPTION,PRICE,LOCATION_NAME
Bicycle,"A folding Bicycle that enables a rider to get around much faster than with Running Shoes.",0,Cerulean City
Pok?? Ball,"A ball thrown to catch a wild Pok??mon. It has a 1x catch rate.",100,Viridian City
Potion,"A spray-type medicine for treating wounds. It restores the HP of one Pok??mon by 20 points.",200,Viridian City
Rare Candy,"A candy that is packed with energy. When consumed, it will instantly raise the level of a single Pok??mon by one.",2500,NULL
Super Potion,"A spray-type medicine for treating wounds. It restores the HP of one Pok??mon by 50 points.",600,Cerulean City
TM28 - Dig,"A TM that teaches the move Dig to a compatible Pok??mon.",1000,Vermilion City
</file>

<file path="database/item_2.csv">
PRICE,RARITY
0,Quest
100,Common
200,Common
600,Uncommon
1000,Rare
2500,Very Rare
</file>

<file path="database/location.csv">
NAME,CLIMATE,TERRAIN_TYPE
Celadon City,Temperate,Urban
Cerulean City,Coastal,Beach
Fuchsia City,Tropical,Swamp
Pallet Town,Temperate,Grassland
Pewter City,Mountainous,Rocky
Route 1,Temperate,Grassland
Saffron City,Temperate,Urban
Vermilion City,Coastal,Port
Viridian City,Temperate,Urban
</file>

<file path="database/move.csv">
MOVE_ID,NAME,POWER,PP,ACCURACY,DESCRIPTION,TYPE_NAME
1,Tackle,40,35,100,"A physical attack in which the user charges and slams INSERT INTO the target with its whole body.",Normal
2,Growl,0,40,100,"The user growls in an endearing way, making opposing Pok??mon less wary and lowering their Attack stats.",Normal
3,Vine Whip,45,25,100,"The target is struck with slender, whip-like vines.",Grass
4,Ember,40,25,100,"The target is attacked with small flames. May also leave the target with a burn.",Fire
5,Flamethrower,90,15,100,"The target is scorched with an intense blast of fire. May also leave the target with a burn.",Fire
6,Water Gun,40,25,100,"The target is blasted with a forceful jet of water.",Water
7,Hydro Pump,110,5,80,"The target is blasted by a huge volume of water launched under great pressure.",Water
8,Thunder Shock,40,30,100,"A jolt of electricity is hurled at the target to inflict damage. May also paralyze the target.",Electric
9,Quick Attack,40,30,100,"The user lunges at the target at a speed that makes it almost invisible.",Normal
10,Double Team,0,15,0,"By moving rapidly, the user makes illusory copies of itself to raise its evasion.",Normal
</file>

<file path="database/player_owns_badge.csv">
TRAINER_ID,BADGE_INDEX
1,1
1,2
1,3
1,4
2,1
2,2
</file>

<file path="database/player.csv">
TRAINER_ID,MONEY
1,5000
2,3000
11,5000
12,3000
13,5000
</file>

<file path="database/pokemon_1.csv">
POKEDEX,POKEMON_ID,NAME,TOTAL_XP,NATURE,HP_IV,ATTACK_IV,DEFENSE_IV,SPEED_IV,ABILITY_ID,TRAINER_ID
1,1,Bulbasaur,1000,Modest,25,15,20,18,4,1
2,1,Ivysaur,3000,Calm,28,18,25,20,4,1
3,1,Venusaur,6000,Bold,31,20,31,22,4,2
4,1,Charmander,1000,Jolly,22,25,18,28,5,3
5,1,Charmeleon,3000,Adamant,26,30,20,25,5,4
6,1,Charizard,6000,Adamant,31,31,22,28,5,5
7,1,Squirtle,1000,Bold,24,18,28,20,6,5
8,1,Wartortle,3000,Relaxed,28,20,30,18,6,6
9,1,Blastoise,6000,Modest,31,15,31,25,6,7
25,1,Pikachu,3000,Timid,20,18,15,31,2,8
25,2,Pikachu,1000,Relaxed,1,31,9,6,11,8
26,1,Raichu,6000,Jolly,25,25,20,31,2,9
</file>

<file path="database/pokemon_2.csv">
NATURE,STAT_INCREASED,STAT_DECREASED
Adamant,Attack,Sp. Atk
Bold,Defense,Attack
Brave,Attack,Speed
Calm,Sp. Def,Attack
Careful,Sp. Def,Sp. Atk
Hasty,Speed,Defense
Impish,Defense,Sp. Atk
Jolly,Speed,Sp. Atk
Lonely,Attack,Defense
Mild,Sp. Atk,Defense
Modest,Sp. Atk,Attack
Naive,Speed,Sp. Def
Quiet,Sp. Atk,Speed
Rash,Sp. Atk,Sp. Def
Relaxed,Defense,Speed
Timid,Speed,Attack
</file>

<file path="database/pokemon_3.csv">
TOTAL_XP,POKEMON_LEVEL
0,1
250,2
500,3
750,4
1000,5
1400,6
1800,7
2200,8
2600,9
3000,10
3600,11
4200,12
4800,13
5400,14
6000,15
6800,16
7600,17
8400,18
9200,19
10000,20
11000,21
12000,22
13000,23
14000,24
15000,25
16200,26
17400,27
18600,28
19800,29
21000,30
22400,31
23800,32
25200,33
26600,34
28000,35
29600,36
31200,37
32800,38
34400,39
36000,40
37800,41
39600,42
41400,43
43200,44
45000,45
</file>

<file path="database/pokemon_has_learned_move.csv">
POKEDEX,POKEMON_ID,MOVE_ID
1,1,1
1,1,2
1,1,3
4,1,1
4,1,2
4,1,4
7,1,1
7,1,2
7,1,6
25,1,1
25,1,8
25,2,9
26,1,8
26,1,9
</file>

<file path="database/setup_all.sql">
-- -- Reset the database
-- @reset.sql

-- -- Create all tables
-- @create_pokemon_db.sql

-- -- Insert sample data  
-- @insert_data.sql

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Player_Owns_Badge CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Belongs_To_Egg_Group CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Located_In CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Can_Have_Ability CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Can_Learn_Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Has_Type CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_Has_Learned_Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Evolves_Into CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Player CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Gym_Leader_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Item_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Trainer CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Gym_Leader_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Item_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_3 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Egg_Group CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Ability CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Badge CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Type CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Location CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

PURGE RECYCLEBIN;

-- Tables with no Foreign Keys
CREATE TABLE
    Location (
        name VARCHAR(40) PRIMARY KEY,
        climate VARCHAR(255) NOT NULL,
        terrain_type VARCHAR(255) NOT NULL
    );

CREATE TABLE
    Type (
        name VARCHAR(9) PRIMARY KEY,
        colour VARCHAR(50) UNIQUE NOT NULL
    );

CREATE TABLE
    Badge (
        badge_index INTEGER PRIMARY KEY,
        name VARCHAR(15) UNIQUE NOT NULL
    );

CREATE TABLE
    Ability (
        ability_id INTEGER PRIMARY KEY,
        name VARCHAR(255) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Species (
        pokedex INTEGER PRIMARY KEY,
        name VARCHAR(12) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Egg_Group (
        egg_group_id INTEGER PRIMARY KEY,
        name VARCHAR(30) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Move (
        move_id INTEGER PRIMARY KEY,
        name VARCHAR(50) UNIQUE NOT NULL,
        power INTEGER NOT NULL,
        pp INTEGER NOT NULL,
        accuracy INTEGER NOT NULL,
        description VARCHAR(1000) NOT NULL,
        type_name VARCHAR(9) NOT NULL,
        FOREIGN KEY (type_name) REFERENCES Type (name)
    );

-- Normalized Tables
CREATE TABLE
    Pokemon_2 (
        nature VARCHAR(12) PRIMARY KEY,
        stat_increased VARCHAR(12) NOT NULL,
        stat_decreased VARCHAR(12) NOT NULL
    );

CREATE TABLE
    Pokemon_3 (
        total_XP INTEGER PRIMARY KEY,
        pokemon_level INTEGER UNIQUE NOT NULL
    );

CREATE TABLE
    Item_2 (
        price INTEGER PRIMARY KEY,
        rarity VARCHAR(10) NOT NULL
    );

CREATE TABLE
    Gym_Leader_2 (
        difficulty INTEGER PRIMARY KEY,
        cash_reward INTEGER NOT NULL
    );

-- Tables with Foreign Keys
CREATE TABLE
    Trainer (
        trainer_id INTEGER PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        location_name VARCHAR(40),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Item_1 (
        name VARCHAR(255) PRIMARY KEY,
        description VARCHAR(1000) NOT NULL,
        price INTEGER,
        location_name VARCHAR(40),
        FOREIGN KEY (price) REFERENCES Item_2 (price),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Pokemon_1 (
        pokedex INTEGER NOT NULL,
        pokemon_id INTEGER NOT NULL,
        name VARCHAR(20) NOT NULL,
        total_XP INTEGER NOT NULL,
        nature VARCHAR(12) NOT NULL,
        HP_IV INTEGER NOT NULL,
        attack_IV INTEGER DEFAULT 0 NOT NULL,
        defense_IV INTEGER DEFAULT 0 NOT NULL,
        speed_IV INTEGER DEFAULT 0 NOT NULL,
        ability_id INTEGER DEFAULT 0 NOT NULL,
        trainer_id INTEGER,
        PRIMARY KEY (pokedex, pokemon_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (total_XP) REFERENCES Pokemon_3 (total_XP),
        FOREIGN KEY (nature) REFERENCES Pokemon_2 (nature),
        FOREIGN KEY (ability_id) REFERENCES Ability (ability_id),
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
    );

CREATE TABLE
    Gym_Leader_1 (
        trainer_id INTEGER PRIMARY KEY,
        difficulty INTEGER NOT NULL,
        specialty_type_name VARCHAR(9) NOT NULL,
        badge_index INTEGER UNIQUE NOT NULL,
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
            ON DELETE CASCADE,
        FOREIGN KEY (difficulty) REFERENCES Gym_Leader_2 (difficulty),
        FOREIGN KEY (specialty_type_name) REFERENCES Type (name),
        FOREIGN KEY (badge_index) REFERENCES Badge (badge_index)
    );

CREATE TABLE
    Player (
        trainer_id INTEGER PRIMARY KEY,
        money INTEGER NOT NULL,
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
            ON DELETE CASCADE
    );

-- Many-to-Many Relationships:
CREATE TABLE
    Species_Evolves_Into (
        old_pokedex INTEGER,
        new_pokedex INTEGER,
        evolution_level INTEGER,
        PRIMARY KEY (old_pokedex, new_pokedex),
        FOREIGN KEY (old_pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (new_pokedex) REFERENCES Species (pokedex)
    );

CREATE TABLE
    Pokemon_Has_Learned_Move (
        pokedex INTEGER,
        pokemon_id INTEGER,
        move_id INTEGER,
        PRIMARY KEY (pokedex, pokemon_id, move_id),
        FOREIGN KEY (pokedex, pokemon_id) REFERENCES Pokemon_1 (pokedex, pokemon_id)
            ON DELETE CASCADE,
        FOREIGN KEY (move_id) REFERENCES Move (move_id)
    );

CREATE TABLE
    Species_Has_Type (
        pokedex INTEGER,
        type_name VARCHAR(9),
        PRIMARY KEY (pokedex, type_name),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (type_name) REFERENCES Type (name)
    );

CREATE TABLE
    Species_Can_Learn_Move (
        pokedex INTEGER,
        move_id INTEGER,
        PRIMARY KEY (pokedex, move_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (move_id) REFERENCES Move (move_id)
    );

CREATE TABLE
    Species_Can_Have_Ability (
        pokedex INTEGER,
        ability_id INTEGER,
        PRIMARY KEY (pokedex, ability_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (ability_id) REFERENCES Ability (ability_id)
    );

CREATE TABLE
    Species_Located_In (
        pokedex INTEGER,
        location_name VARCHAR(40),
        PRIMARY KEY (pokedex, location_name),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Species_Belongs_To_Egg_Group (
        pokedex INTEGER,
        egg_group_id INTEGER,
        PRIMARY KEY (pokedex, egg_group_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (egg_group_id) REFERENCES Egg_Group (egg_group_id)
    );

CREATE TABLE
    Player_Owns_Badge (
        trainer_id INTEGER,
        badge_index INTEGER,
        PRIMARY KEY (trainer_id, badge_index),
        FOREIGN KEY (trainer_id) REFERENCES Player (trainer_id)
            ON DELETE CASCADE,
        FOREIGN KEY (badge_index) REFERENCES Badge (badge_index)
    );


INSERT INTO Location (name, climate, terrain_type) VALUES ('Pallet Town', 'Temperate', 'Grassland');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Viridian City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Pewter City', 'Mountainous', 'Rocky');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Cerulean City', 'Coastal', 'Beach');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Vermilion City', 'Coastal', 'Port');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Celadon City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Fuchsia City', 'Tropical', 'Swamp');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Saffron City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Route 1', 'Temperate', 'Grassland');

INSERT INTO Type (name, colour) VALUES ('Normal', 'Tan');
INSERT INTO Type (name, colour) VALUES ('Fire', 'Red');
INSERT INTO Type (name, colour) VALUES ('Water', 'Blue');
INSERT INTO Type (name, colour) VALUES ('Electric', 'Yellow');
INSERT INTO Type (name, colour) VALUES ('Grass', 'Green');
INSERT INTO Type (name, colour) VALUES ('Ice', 'Light Blue');
INSERT INTO Type (name, colour) VALUES ('Fighting', 'Brown');
INSERT INTO Type (name, colour) VALUES ('Poison', 'Purple');
INSERT INTO Type (name, colour) VALUES ('Ground', 'Earth');
INSERT INTO Type (name, colour) VALUES ('Flying', 'Sky Blue');
INSERT INTO Type (name, colour) VALUES ('Psychic', 'Pink');
INSERT INTO Type (name, colour) VALUES ('Bug', 'Olive');
INSERT INTO Type (name, colour) VALUES ('Rock', 'Gray');
INSERT INTO Type (name, colour) VALUES ('Ghost', 'Indigo');
INSERT INTO Type (name, colour) VALUES ('Dragon', 'Dark Blue');
INSERT INTO Type (name, colour) VALUES ('Dark', 'Black');
INSERT INTO Type (name, colour) VALUES ('Steel', 'Silver');
INSERT INTO Type (name, colour) VALUES ('Fairy', 'Light Pink');

INSERT INTO Badge (badge_index, name) VALUES (1, 'Boulder Badge');
INSERT INTO Badge (badge_index, name) VALUES (2, 'Cascade Badge');
INSERT INTO Badge (badge_index, name) VALUES (3, 'Thunder Badge');
INSERT INTO Badge (badge_index, name) VALUES (4, 'Rainbow Badge');
INSERT INTO Badge (badge_index, name) VALUES (5, 'Soul Badge');
INSERT INTO Badge (badge_index, name) VALUES (6, 'Marsh Badge');

INSERT INTO Ability (ability_id, name, description) VALUES (2, 'Static', 'Contact with the Pokémon may cause paralysis.');
INSERT INTO Ability (ability_id, name, description) VALUES (4, 'Overgrow', 'Powers up Grass-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (5, 'Blaze', 'Powers up Fire-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (6, 'Torrent', 'Powers up Water-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (8, 'Chlorophyll', 'Boosts the Pokémon''s Speed stat in harsh sunlight.');
INSERT INTO Ability (ability_id, name, description) VALUES (9, 'Solar Power', 'Boosts the Sp. Atk stat in harsh sunlight, but HP decreases every turn.');
INSERT INTO Ability (ability_id, name, description) VALUES (10, 'Rain Dish', 'The Pokémon gradually regains HP in rain.');
INSERT INTO Ability (ability_id, name, description) VALUES (11, 'Lightning Rod', 'Draws in all Electric-type moves to boost its Sp. Atk stat.');

INSERT INTO Species (pokedex, name, description) VALUES (1, 'Bulbasaur', 'It carries a seed on its back right from birth. As its body grows larger, the seed does too.');
INSERT INTO Species (pokedex, name, description) VALUES (2, 'Ivysaur', 'The bulb on its back grows as it absorbs nutrients. The bulb gives off a pleasant aroma when it blooms.');
INSERT INTO Species (pokedex, name, description) VALUES (3, 'Venusaur', 'By spreading the broad petals of its flower and catching the sun''s rays, it fills its body with power.');
INSERT INTO Species (pokedex, name, description) VALUES (4, 'Charmander', 'The flame on its tail shows the strength of its life-force. If Charmander is weak, the flame also burns weakly.');
INSERT INTO Species (pokedex, name, description) VALUES (5, 'Charmeleon', 'It is very hotheaded by nature, so it constantly seeks opponents to battle against. Its aggression will not be quelled if it doesn''t win.');
INSERT INTO Species (pokedex, name, description) VALUES (6, 'Charizard', 'The flame inside its body burns hotter than 3,600 degrees Fahrenheit. When Charizard roars, that temperature climbs even higher.');
INSERT INTO Species (pokedex, name, description) VALUES (7, 'Squirtle', 'Its shell is soft immediately after it is born. In no time at all, the shell becomes so resilient that a prodding finger will bounce right off it.');
INSERT INTO Species (pokedex, name, description) VALUES (8, 'Wartortle', 'It often hides in water to stalk unwary prey. While swimming quickly, it moves its ears to maintain balance.');
INSERT INTO Species (pokedex, name, description) VALUES (9, 'Blastoise', 'It has jet nozzles on its shell. This impressive Pokémon uses these jets to charge toward foes with all the force of a rocket.');
INSERT INTO Species (pokedex, name, description) VALUES (25, 'Pikachu', 'When several of these Pokémon gather, their electricity can build and cause lightning storms.');
INSERT INTO Species (pokedex, name, description) VALUES (26, 'Raichu', 'Its tail discharges electricity into the ground, protecting it from getting shocked.');

INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (1, 'Mineral', 'Pokemon in this group are inorganic in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (2, 'Amorphous', 'Pokemon in this group are amorphous, having no definite form');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (3, 'Grass', 'Pokemon in this group are plantlike in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (4, 'Water 3', 'Pokemon in this group resemble aquatic invertebrates');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (5, 'Water 2', 'Pokemon in this group are piscine (fishlike) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (6, 'Water 1', 'Pokemon in this group are amphibious in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (7, 'Bug', 'Pokemon in this group are insectoid (bug-like) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (8, 'Dragon', 'Pokemon in this group are reptilian or draconic in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (9, 'Flying', 'Pokemon in this group are avian (birdlike) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (10, 'Field', 'The largest group, Pokemon here are terrestrial in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (11, 'Human-Like', 'Pokemon in this group are fully bipedal humanoids');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (12, 'Fairy', 'Pokemon in this group are petite and considered very cute');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (13, 'Monster', 'Pokemon in this group are saurian/kaiju-like in appearance and nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (14, 'Ditto', 'Ditto is the only Pokemon in this group, capable of breeding with most others');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (15, 'No Eggs Discovered', 'Pokemon in this group are unable to breed');

INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (1, 'Tackle', 40, 35, 100, 'A physical attack in which the user charges and slams INSERT INTO the target with its whole body.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (2, 'Growl', 0, 40, 100, 'The user growls in an endearing way, making opposing Pokémon less wary and lowering their Attack stats.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (3, 'Vine Whip', 45, 25, 100, 'The target is struck with slender, whip-like vines.', 'Grass');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (4, 'Ember', 40, 25, 100, 'The target is attacked with small flames. May also leave the target with a burn.', 'Fire');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (5, 'Flamethrower', 90, 15, 100, 'The target is scorched with an intense blast of fire. May also leave the target with a burn.', 'Fire');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (6, 'Water Gun', 40, 25, 100, 'The target is blasted with a forceful jet of water.', 'Water');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (7, 'Hydro Pump', 110, 5, 80, 'The target is blasted by a huge volume of water launched under great pressure.', 'Water');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (8, 'Thunder Shock', 40, 30, 100, 'A jolt of electricity is hurled at the target to inflict damage. May also paralyze the target.', 'Electric');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (9, 'Quick Attack', 40, 30, 100, 'The user lunges at the target at a speed that makes it almost invisible.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (10, 'Double Team', 0, 15, 0, 'By moving rapidly, the user makes illusory copies of itself to raise its evasion.', 'Normal');

INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Adamant', 'Attack', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Modest', 'Sp. Atk', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Jolly', 'Speed', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Timid', 'Speed', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Bold', 'Defense', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Impish', 'Defense', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Calm', 'Sp. Def', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Careful', 'Sp. Def', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Naive', 'Speed', 'Sp. Def');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Hasty', 'Speed', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Brave', 'Attack', 'Speed');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Quiet', 'Sp. Atk', 'Speed');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Rash', 'Sp. Atk', 'Sp. Def');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Lonely', 'Attack', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Mild', 'Sp. Atk', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Relaxed', 'Defense', 'Speed');

INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (1, 0);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (2, 250);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (3, 500);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (4, 750);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (5, 1000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (6, 1400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (7, 1800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (8, 2200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (9, 2600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (10, 3000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (11, 3600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (12, 4200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (13, 4800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (14, 5400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (15, 6000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (16, 6800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (17, 7600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (18, 8400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (19, 9200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (20, 10000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (21, 11000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (22, 12000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (23, 13000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (24, 14000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (25, 15000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (26, 16200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (27, 17400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (28, 18600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (29, 19800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (30, 21000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (31, 22400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (32, 23800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (33, 25200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (34, 26600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (35, 28000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (36, 29600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (37, 31200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (38, 32800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (39, 34400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (40, 36000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (41, 37800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (42, 39600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (43, 41400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (44, 43200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (45, 45000);

INSERT INTO Item_2 (price, rarity) VALUES (0, 'Quest');
INSERT INTO Item_2 (price, rarity) VALUES (100, 'Common');
INSERT INTO Item_2 (price, rarity) VALUES (200, 'Common');
INSERT INTO Item_2 (price, rarity) VALUES (600, 'Uncommon');
INSERT INTO Item_2 (price, rarity) VALUES (1000, 'Rare');
INSERT INTO Item_2 (price, rarity) VALUES (2500, 'Very Rare');

INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (1, 1000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (2, 2000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (3, 3000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (4, 5000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (5, 10000);

INSERT INTO Trainer (trainer_id, name, location_name) VALUES (1, 'Ash', 'Pallet Town');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (2, 'Gary', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (3, 'Brock', 'Pewter City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (4, 'Misty', 'Cerulean City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (5, 'Lt. Surge', 'Vermilion City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (6, 'Erika', 'Celadon City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (7, 'Koga', 'Fuchsia City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (8, 'Sabrina', 'Saffron City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (9, 'Blaine', 'Route 1');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (10, 'Giovanni', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (11, 'John', 'Pallet Town');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (12, 'Joe', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (13, 'Amanda', NULL);

INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Poké Ball', 'A ball thrown to catch a wild Pokémon. It has a 1x catch rate.', 100, 'Viridian City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Potion', 'A spray-type medicine for treating wounds. It restores the HP of one Pokémon by 20 points.', 200, 'Viridian City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Super Potion', 'A spray-type medicine for treating wounds. It restores the HP of one Pokémon by 50 points.', 600, 'Cerulean City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('TM28 - Dig', 'A TM that teaches the move Dig to a compatible Pokémon.', 1000, 'Vermilion City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Rare Candy', 'A candy that is packed with energy. When consumed, it will instantly raise the level of a single Pokémon by one.', 2500, NULL);
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Bicycle', 'A folding Bicycle that enables a rider to get around much faster than with Running Shoes.', 0, 'Cerulean City');

INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (1, 1, 'Bulbasaur', 1000, 'Modest', 25, 15, 20, 18, 4, 1);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (2, 1, 'Ivysaur', 3000, 'Calm', 28, 18, 25, 20, 4, 1);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (3, 1, 'Venusaur', 6000, 'Bold', 31, 20, 31, 22, 4, 2);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (4, 1, 'Charmander', 1000, 'Jolly', 22, 25, 18, 28, 5, 3);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (5, 1, 'Charmeleon', 3000, 'Adamant', 26, 30, 20, 25, 5, 4);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (6, 1, 'Charizard', 6000, 'Adamant', 31, 31, 22, 28, 5, 5);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (7, 1, 'Squirtle', 1000, 'Bold', 24, 18, 28, 20, 6, 5);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (8, 1, 'Wartortle', 3000, 'Relaxed', 28, 20, 30, 18, 6, 6);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (9, 1, 'Blastoise', 6000, 'Modest', 31, 15, 31, 25, 6, 7);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (25, 1, 'Pikachu', 3000, 'Timid', 20, 18, 15, 31, 2, 8);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (25, 2, 'Pikachu', 1000, 'Relaxed', 1, 31, 9, 6, 11, 8);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (26, 1, 'Raichu', 6000, 'Jolly', 25, 25, 20, 31, 2, 9);

INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (3, 1, 'Rock', 1);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (4, 2, 'Water', 2);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (5, 3, 'Electric', 3);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (6, 4, 'Grass', 4);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (7, 5, 'Poison', 5);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (8, 5, 'Psychic', 6);

INSERT INTO Player (trainer_id, money) VALUES (1, 5000);
INSERT INTO Player (trainer_id, money) VALUES (2, 3000);
INSERT INTO Player (trainer_id, money) VALUES (11, 5000);
INSERT INTO Player (trainer_id, money) VALUES (12, 3000);
INSERT INTO Player (trainer_id, money) VALUES (13, 5000);

INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (1, 2, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (2, 3, 32);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (4, 5, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (5, 6, 36);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (7, 8, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (8, 9, 36);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (25, 26, NULL);

INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 3);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 4);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 6);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 1, 8);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 2, 9);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (26, 1, 8);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (26, 1, 9);

INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (1, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (1, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (2, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (2, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (3, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (3, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (4, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (5, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (6, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (6, 'Flying');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (7, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (8, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (9, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (25, 'Electric');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (26, 'Electric');

INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (4, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (4, 4);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (5, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (5, 5);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (6, 5);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (6, 9);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (7, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (7, 6);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (8, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (8, 6);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (9, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (9, 7);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 8);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 9);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 10);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (26, 8);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (26, 9);

INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (1, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (1, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (2, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (2, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (3, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (3, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (4, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (4, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (5, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (5, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (6, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (6, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (7, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (7, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (8, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (8, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (9, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (9, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (25, 2);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (25, 11);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (26, 2);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (26, 11);

INSERT INTO Species_Located_In (pokedex, location_name) VALUES (1, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (4, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (7, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (25, 'Viridian City');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (25, 'Vermilion City');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (26, 'Vermilion City');

INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (1, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (1, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (2, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (2, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (3, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (3, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (4, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (4, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (5, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (5, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (6, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (6, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (7, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (7, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (8, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (8, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (9, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (9, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (25, 10);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (25, 12);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (26, 10);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (26, 12);

INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 1);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 2);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 3);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 4);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (2, 1);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (2, 2);
</file>

<file path="database/species_belongs_to_egg_group.csv">
POKEDEX,EGG_GROUP_ID
1,3
1,13
2,3
2,13
3,3
3,13
4,8
4,13
5,8
5,13
6,8
6,13
7,6
7,13
8,6
8,13
9,6
9,13
25,10
25,12
26,10
26,12
</file>

<file path="database/species_can_have_ability.csv">
POKEDEX,ABILITY_ID
1,4
1,8
2,4
2,8
3,4
3,8
4,5
4,9
5,5
5,9
6,5
6,9
7,6
7,10
8,6
8,10
9,6
9,10
25,2
25,11
26,2
26,11
</file>

<file path="database/species_can_learn_move.csv">
POKEDEX,MOVE_ID
1,1
1,2
1,3
2,1
2,2
2,3
3,1
3,2
3,3
4,1
4,4
5,1
5,5
6,5
6,9
7,1
7,6
8,1
8,6
9,1
9,7
25,8
25,9
25,10
26,8
26,9
</file>

<file path="database/species_evolves_into.csv">
OLD_POKEDEX,NEW_POKEDEX,EVOLUTION_LEVEL
1,2,16
2,3,32
4,5,16
5,6,36
7,8,16
8,9,36
25,26,0
</file>

<file path="database/species_has_type.csv">
POKEDEX,TYPE_NAME
1,Grass
1,Poison
2,Grass
2,Poison
3,Grass
3,Poison
4,Fire
5,Fire
6,Fire
6,Flying
7,Water
8,Water
9,Water
25,Electric
26,Electric
</file>

<file path="database/species_located_in.csv">
POKEDEX,LOCATION_NAME
1,Pallet Town
4,Pallet Town
7,Pallet Town
25,Vermilion City
25,Viridian City
26,Vermilion City
</file>

<file path="database/species.csv">
POKEDEX,NAME,DESCRIPTION
1,Bulbasaur,"It carries a seed on its back right from birth. As its body grows larger, the seed does too."
2,Ivysaur,"The bulb on its back grows as it absorbs nutrients. The bulb gives off a pleasant aroma when it blooms."
3,Venusaur,"By spreading the broad petals of its flower and catching the sun's rays, it fills its body with power."
4,Charmander,"The flame on its tail shows the strength of its life-force. If Charmander is weak, the flame also burns weakly."
5,Charmeleon,"It is very hotheaded by nature, so it constantly seeks opponents to battle against. Its aggression will not be quelled if it doesn't win."
6,Charizard,"The flame inside its body burns hotter than 3,600 degrees Fahrenheit. When Charizard roars, that temperature climbs even higher."
7,Squirtle,"Its shell is soft immediately after it is born. In no time at all, the shell becomes so resilient that a prodding finger will bounce right off it."
8,Wartortle,"It often hides in water to stalk unwary prey. While swimming quickly, it moves its ears to maintain balance."
9,Blastoise,"It has jet nozzles on its shell. This impressive Pok??mon uses these jets to charge toward foes with all the force of a rocket."
25,Pikachu,"When several of these Pok??mon gather, their electricity can build and cause lightning storms."
26,Raichu,"Its tail discharges electricity into the ground, protecting it from getting shocked."
</file>

<file path="database/trainer.csv">
TRAINER_ID,NAME,LOCATION_NAME
1,Ash,Pallet Town
2,Gary,NULL
3,Brock,Pewter City
4,Misty,Cerulean City
5,Lt. Surge,Vermilion City
6,Erika,Celadon City
7,Koga,Fuchsia City
8,Sabrina,Saffron City
9,Blaine,Route 1
10,Giovanni,NULL
11,John,Pallet Town
12,Joe,NULL
13,Amanda,NULL
</file>

<file path="database/type.csv">
NAME,COLOUR
Bug,Olive
Dark,Black
Dragon,Dark Blue
Electric,Yellow
Fairy,Light Pink
Fighting,Brown
Fire,Red
Flying,Sky Blue
Ghost,Indigo
Grass,Green
Ground,Earth
Ice,Light Blue
Normal,Tan
Poison,Purple
Psychic,Pink
Rock,Gray
Steel,Silver
Water,Blue
</file>

<file path="frontend/remote-start.sh">
#!/bin/bash

# Set Oracle environment
if [ -d /cs/software/rpms/oracle_client-signed/instantclient_23_7/instantclient_23_7 ]; then
    export ORACLE_HOME=/cs/software/rpms/oracle_client-signed/instantclient_23_7/instantclient_23_7
    export LD_LIBRARY_PATH=$ORACLE_HOME
elif [ -d /cs/software/rpms/oracle_client-signed/instantclient_23_4 ]; then
    export ORACLE_HOME=/cs/software/rpms/oracle_client-signed/instantclient_23_4
    export LD_LIBRARY_PATH=$ORACLE_HOME
elif [ -d /cs/software/rpms/oracle_client-signed/instantclient_21_11 ]; then
    export ORACLE_HOME=/cs/software/rpms/oracle_client-signed/instantclient_21_11
    export LD_LIBRARY_PATH=$ORACLE_HOME
else
    echo "Oracle not found..."
    exit 1
fi 


# Configure the shared Node library on the undergrad server.
export NODE_PATH=/cs/local/generic/lib/cs304/node_modules

# File path
ENV_SERVER_PATH="./.env"

# Check the database host name and port
sed -i "/^ORACLE_HOST=/c\ORACLE_HOST=dbhost.students.cs.ubc.ca" $ENV_SERVER_PATH
sed -i "/^ORACLE_PORT=/c\ORACLE_PORT=1522" $ENV_SERVER_PATH

# Define a range
START=50000
END=60000

# Loop through the range and check if the port is in use
for PORT in $(seq $START $END); do
    # Check if the port is in use
    if ! ss -tuln | grep :$PORT > /dev/null; then
        # Bind to the port using a temporary process
        nc -l -p $PORT &
        TEMP_PID=$!

        # Update the port number in the .env file
        sed -i "/^PORT=/c\PORT=$PORT" $ENV_SERVER_PATH
        echo "Updated $ENV_SERVER_PATH with PORT=$PORT."

        # Kill the temporary process
        kill $TEMP_PID

        # Replace the bash process with the Node process
        exec node server.js
        break
    fi
done
</file>

<file path="queries.txt">
INSERT
Trainer, Player, Pokemon_1, Pokemon_Has_Learned_Move

DELETE
Trainer (Player, Gym Leader), Pokemon_1 (Pokemon_Has_Learned_Move, )

UPDATE
Trainer, Player, Pokemon_1, Pokemon_Has_Learned_Move

Selection
Pokemon_1

Projection
All tables

Join
Species_Located_In

AGGREGATION (GROUP BY)
Pokemon_1 - Return the pokemon each trainer owns that has the lowest defense iv

AGGREGATION (HAVING)
Pokemon_1 - Return the pokemon each trainer owns that has the highest xp where each trainer has at least two pokemon

Nested Aggregation with GROUP BY
Find trainers with pokemon with above average XP
Compute avg Xp of all pokemon, compare each pokemon to the avg, group by trainer

Division
Species_Has_Type - Return all species that have a specific type or 2 types
</file>

<file path="database/reset.sql">
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Player_Owns_Badge CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Belongs_To_Egg_Group CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Located_In CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Can_Have_Ability CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Can_Learn_Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Has_Type CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_Has_Learned_Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species_Evolves_Into CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Player CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Gym_Leader_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Item_1 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Trainer CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Gym_Leader_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Item_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_3 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Pokemon_2 CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Move CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Egg_Group CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Species CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Ability CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Badge CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Type CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE Location CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

PURGE RECYCLEBIN;
</file>

<file path="README.md">
# Pokemon Game Management Database System

## Project Description

The application is meant to be a Pokemon game management lookup system. The database models Pokemon species as well as individual Pokemon. Each Pokemon species has one or two types, can learn certain moves (which also have their own types), can have certain abilities, may evolve into another species, and has one specific egg group. Each individual Pokemon knows up to 4 moves, has a certain ability, and is owned by a trainer as part of the trainer's Pokemon collection. A trainer can be a regular NPC trainer, or they can be either a player character or a gym leader. The database also models locations, where trainers, Pokemon species, and items are found in the game.

## Course Information

**Course:** CPSC 304 - Introduction to Relational Databases  
**Term:** 2025S2

## Group Information

**Group Number**: 36

## Members

**Graydon Strachan**

**Anthony Lu**

**Dikpaal Patel**
</file>

<file path="database/create_pokemon_db.sql">
-- Tables with no Foreign Keys
CREATE TABLE
    Location (
        name VARCHAR(40) PRIMARY KEY,
        climate VARCHAR(255) NOT NULL,
        terrain_type VARCHAR(255) NOT NULL
    );

CREATE TABLE
    Type (
        name VARCHAR(9) PRIMARY KEY,
        colour VARCHAR(50) UNIQUE NOT NULL
    );

CREATE TABLE
    Badge (
        badge_index INTEGER PRIMARY KEY,
        name VARCHAR(15) UNIQUE NOT NULL
    );

CREATE TABLE
    Ability (
        ability_id INTEGER PRIMARY KEY,
        name VARCHAR(255) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Species (
        pokedex INTEGER PRIMARY KEY,
        name VARCHAR(12) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Egg_Group (
        egg_group_id INTEGER PRIMARY KEY,
        name VARCHAR(30) UNIQUE NOT NULL,
        description VARCHAR(1000) NOT NULL
    );

CREATE TABLE
    Move (
        move_id INTEGER PRIMARY KEY,
        name VARCHAR(50) UNIQUE NOT NULL,
        power INTEGER NOT NULL,
        pp INTEGER NOT NULL,
        accuracy INTEGER NOT NULL,
        description VARCHAR(1000) NOT NULL,
        type_name VARCHAR(9) NOT NULL,
        FOREIGN KEY (type_name) REFERENCES Type (name)
    );

-- Normalized Tables
CREATE TABLE
    Pokemon_2 (
        nature VARCHAR(12) PRIMARY KEY,
        stat_increased VARCHAR(12) NOT NULL,
        stat_decreased VARCHAR(12) NOT NULL
    );

CREATE TABLE
    Pokemon_3 (
        total_XP INTEGER PRIMARY KEY,
        pokemon_level INTEGER UNIQUE NOT NULL
    );

CREATE TABLE
    Item_2 (
        price INTEGER PRIMARY KEY,
        rarity VARCHAR(10) NOT NULL
    );

CREATE TABLE
    Gym_Leader_2 (
        difficulty INTEGER PRIMARY KEY,
        cash_reward INTEGER NOT NULL
    );

-- Tables with Foreign Keys
CREATE TABLE
    Trainer (
        trainer_id INTEGER PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        location_name VARCHAR(40),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Item_1 (
        name VARCHAR(255) PRIMARY KEY,
        description VARCHAR(1000) NOT NULL,
        price INTEGER,
        location_name VARCHAR(40),
        FOREIGN KEY (price) REFERENCES Item_2 (price),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Pokemon_1 (
        pokedex INTEGER NOT NULL,
        pokemon_id INTEGER NOT NULL,
        name VARCHAR(20) NOT NULL,
        total_XP INTEGER NOT NULL,
        nature VARCHAR(12) NOT NULL,
        HP_IV INTEGER NOT NULL,
        attack_IV INTEGER DEFAULT 0 NOT NULL,
        defense_IV INTEGER DEFAULT 0 NOT NULL,
        speed_IV INTEGER DEFAULT 0 NOT NULL,
        ability_id INTEGER DEFAULT 0 NOT NULL,
        trainer_id INTEGER,
        PRIMARY KEY (pokedex, pokemon_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (total_XP) REFERENCES Pokemon_3 (total_XP),
        FOREIGN KEY (nature) REFERENCES Pokemon_2 (nature),
        FOREIGN KEY (ability_id) REFERENCES Ability (ability_id),
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
    );

CREATE TABLE
    Gym_Leader_1 (
        trainer_id INTEGER PRIMARY KEY,
        difficulty INTEGER NOT NULL,
        specialty_type_name VARCHAR(9) NOT NULL,
        badge_index INTEGER UNIQUE NOT NULL,
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
            ON DELETE CASCADE,
        FOREIGN KEY (difficulty) REFERENCES Gym_Leader_2 (difficulty),
        FOREIGN KEY (specialty_type_name) REFERENCES Type (name),
        FOREIGN KEY (badge_index) REFERENCES Badge (badge_index)
    );

CREATE TABLE
    Player (
        trainer_id INTEGER PRIMARY KEY,
        money INTEGER NOT NULL,
        FOREIGN KEY (trainer_id) REFERENCES Trainer (trainer_id)
            ON DELETE CASCADE
    );

-- Many-to-Many Relationships:
CREATE TABLE
    Species_Evolves_Into (
        old_pokedex INTEGER,
        new_pokedex INTEGER,
        evolution_level INTEGER,
        PRIMARY KEY (old_pokedex, new_pokedex),
        FOREIGN KEY (old_pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (new_pokedex) REFERENCES Species (pokedex)
    );

CREATE TABLE
    Pokemon_Has_Learned_Move (
        pokedex INTEGER,
        pokemon_id INTEGER,
        move_id INTEGER,
        PRIMARY KEY (pokedex, pokemon_id, move_id),
        FOREIGN KEY (pokedex, pokemon_id) REFERENCES Pokemon_1 (pokedex, pokemon_id)
            ON DELETE CASCADE,
        FOREIGN KEY (move_id) REFERENCES Move (move_id)
    );

CREATE TABLE
    Species_Has_Type (
        pokedex INTEGER,
        type_name VARCHAR(9),
        PRIMARY KEY (pokedex, type_name),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (type_name) REFERENCES Type (name)
    );

CREATE TABLE
    Species_Can_Learn_Move (
        pokedex INTEGER,
        move_id INTEGER,
        PRIMARY KEY (pokedex, move_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (move_id) REFERENCES Move (move_id)
    );

CREATE TABLE
    Species_Can_Have_Ability (
        pokedex INTEGER,
        ability_id INTEGER,
        PRIMARY KEY (pokedex, ability_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (ability_id) REFERENCES Ability (ability_id)
    );

CREATE TABLE
    Species_Located_In (
        pokedex INTEGER,
        location_name VARCHAR(40),
        PRIMARY KEY (pokedex, location_name),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (location_name) REFERENCES Location (name)
    );

CREATE TABLE
    Species_Belongs_To_Egg_Group (
        pokedex INTEGER,
        egg_group_id INTEGER,
        PRIMARY KEY (pokedex, egg_group_id),
        FOREIGN KEY (pokedex) REFERENCES Species (pokedex),
        FOREIGN KEY (egg_group_id) REFERENCES Egg_Group (egg_group_id)
    );

CREATE TABLE
    Player_Owns_Badge (
        trainer_id INTEGER,
        badge_index INTEGER,
        PRIMARY KEY (trainer_id, badge_index),
        FOREIGN KEY (trainer_id) REFERENCES Player (trainer_id)
            ON DELETE CASCADE,
        FOREIGN KEY (badge_index) REFERENCES Badge (badge_index)
    );
</file>

<file path="frontend/public/styles.css">
/* GLOBAL STYLES */
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    padding: 40px;
    max-width: 800px;
    margin: auto;
    line-height: 1.6;
    background-color: #fffef5f9;
    color: #313131;
}

hr {
    border-top: 2px solid rgb(44, 51, 62);
    margin: auto;
}

/* TABLE STYLES */
table {
    margin-top: 10px;
    width: 100%;
    border-collapse: collapse;
    background-color: #fff;
    box-shadow: 0 1px 12px rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

th, td {
    padding: 12px 15px;
    border-bottom: 1px solid #ddd;
}

th {
    background-color: #f2f2f2;
    font-weight: bold;
}

tr:last-child td {
    border-bottom: none;
}

tr:hover {
    background-color: #f5f5f5;
    cursor: pointer;
}

button {
    background-color: rgb(32, 107, 227);
    color: #fff;
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    outline: none;
}

button:hover {
    background-color: rgb(22, 87, 207);
}

button:active {
    background-color: rgb(12, 67, 187);
}

/* INPUT STYLES */
input, textarea {
    width: 100%;
}

input, textarea, select {
    padding: 10px 15px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #fff;
    color: #333;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    margin-bottom: 10px;
}

input::placeholder, textarea::placeholder, select::placeholder {
    color: #aaa;
}

#attributeCheckboxes input[type="checkbox"],
#typeCheckboxes input[type="checkbox"] {
    width: auto;
    margin: 0;
}

select:hover {
  border-color: #999;
}

select option {
  padding: 10px 15px;
  font-size: 16px;
  background-color: #fff;
  color: #333;
}

/* OTHER STYLES */
.loading-gif {
    height: 1em;
    vertical-align: middle;
}
</file>

<file path="frontend/appController.js">
const express = require('express');
const appService = require('./appService');

const router = express.Router();

// ----------------------------------------------------------
// API endpoints

// SYSTEM ENDPOINTS
router.get('/check-db-connection', async (req, res) => {
    const isConnected = await appService.testOracleConnection();
    if (isConnected) {
        res.send('connected');
    } else {
        res.send('unable to connect');
    }
});

router.post("/initiate-database", async (req, res) => {
    const initiateResult = await appService.initiatePokemonDB();
    if (initiateResult) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

// FETCH ENDPOINTS
router.get('/trainers', async (req, res) => {
    const tableContent = await appService.fetchTrainersFromDb();
    res.json({data: tableContent});
});

router.get('/players', async (req, res) => {
    const tableContent = await appService.fetchPlayersFromDb();
    res.json({data: tableContent});
});

router.get('/pokemon', async (req, res) => {
    const tableContent = await appService.fetchPokemonFromDb();
    res.json({data: tableContent});
});

router.get('/learned-moves', async (req, res) => {
    const tableContent = await appService.fetchLearnedMovesFromDb();
    res.json({data: tableContent});
});

router.get('/species', async (req, res) => {
    const tableContent = await appService.fetchSpeciesFromDb();
    res.json({data: tableContent});
});

router.get('/moves', async (req, res) => {
    const tableContent = await appService.fetchMovesFromDb();
    res.json({data: tableContent});
});

router.get('/types', async (req, res) => {
    try {
        const types = await appService.fetchAllTypes();
        res.json({ success: true, data: types });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/abilities', async (req, res) => {
    const tableContent = await appService.fetchAbilitiesFromDb();
    res.json({data: tableContent});
});

router.get('/natures', async (req, res) => {
    const tableContent = await appService.fetchNaturesFromDb();
    res.json({data: tableContent});
});

// INSERT ENDPOINTS
router.post("/insert-trainer", async (req, res) => {
    const { trainerId, name, locationName } = req.body;
    const insertTrainerResults = await appService.insertTrainer(trainerId, name, locationName);
    if (insertTrainerResults) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

router.post("/insert-player", async (req, res) => {
    const { trainerId, money } = req.body;
    const insertPlayerResults = await appService.insertPlayer(trainerId, money);
    if (insertPlayerResults) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

router.post("/insert-pokemon", async (req, res) => {
    const { pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id } = req.body;
    const insertPokemonResults = await appService.insertPokemon(pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id);
    if (insertPokemonResults) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

router.post("/insert-learned-move", async (req, res) => {
    const { pokedex, pokemon_id, move_id } = req.body;
    const insertLearnedMoveResults = await appService.insertPokemonHasLearnedMove(pokedex, pokemon_id, move_id);
    if (insertLearnedMoveResults) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

// DELETE ENDPOINTS
router.delete('/delete-trainer', async (req, res) => {
    const { trainerId } = req.body;
    const success = await appService.deleteTrainer(trainerId);
    if (success) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

router.delete('/delete-pokemon', async (req, res) => {
    const { pokedex, pokemon_id } = req.body;
    const success = await appService.deletePokemon(pokedex, pokemon_id);
    if (success) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

router.delete('/delete-learned-move', async (req, res) => {
    const { pokedex, pokemon_id, move_id } = req.body;
    const success = await appService.deletePokemonHasLearnedMove(pokedex, pokemon_id, move_id);
    if (success) {
        res.json({ success: true });
    } else {
        res.status(500).json({ success: false });
    }
});

// UPDATE ENDPOINTS
router.post('/update-trainer', async (req, res) => {
    try {
        const { trainerId, updates } = req.body;
        const success = await appService.updateTrainer(trainerId, updates);
        res.json({ success, message: "Trainer updated successfully" });
    } catch (err) {
        res.status(400).json({ success: false, message: err.message });
    }
});

router.post('/update-player', async (req, res) => {
    try {
        const { trainerId, updates } = req.body;
        const success = await appService.updatePlayer(trainerId, updates);
        res.json({ success, message: "Player updated successfully" });
    } catch (err) {
        res.status(400).json({ success: false, message: err.message });
    }
});

router.post('/update-pokemon', async (req, res) => {
    try {
        const { pokedex, pokemonId, updates } = req.body;
        const success = await appService.updatePokemon(pokedex, pokemonId, updates);
        res.json({ success, message: "Pokemon updated successfully" });
    } catch (err) {
        res.status(400).json({ success: false, message: err.message });
    }
});

router.post('/update-learned-move', async (req, res) => {
    try {
        const { pokedex, pokemonId, oldMoveId, newMoveId } = req.body;
        const success = await appService.updatePokemonHasLearnedMove(pokedex, pokemonId, oldMoveId, newMoveId);
        res.json({ success, message: "Move updated successfully" });
    } catch (err) {
        res.status(400).json({ success: false, message: err.message });
    }
});

// SELECTION ENDPOINTS
router.post('/selection-query', async (req, res) => {
    try {
        const { conditions } = req.body;
        const data = await appService.executeSelectionQuery(conditions);
        res.json({ success: true, data });
    } catch (err) {
        if (err.message.includes("Invalid")) {
            res.status(400).json({ success: false, message: err.message });
        } else {
            res.status(500).json({ success: false, message: 'An error occurred while executing the query.' });
        }
    }
});

// PROJECTION ENDPOINTS
router.get('/tables', async (req, res) => {
    try {
        const tables = await appService.fetchTableNames();
        res.json({ success: true, data: tables });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/columns/:tableName', async (req, res) => {
    try {
        const tableName = req.params.tableName;
        const columns = await appService.fetchColumnNames(tableName);
        res.json({ success: true, data: columns });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.post('/project', async (req, res) => {
    try {
        const { table, attributes } = req.body;
        const data = await appService.executeProjectionQuery(table, attributes);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// JOIN ENDPOINTS
router.get('/join/species-location', async (req, res) => {
    try {
        const { location } = req.query;
        const data = await appService.executeSpeciesLocationJoin(location);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/locations', async (req, res) => {
    try {
        const locations = await appService.fetchLocationsForJoin();
        res.json({ success: true, data: locations });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// AGGREGATION WITH GROUP BY ENDPOINTS
router.get('/aggregation/defense-iv', async (req, res) => {
    try {
        const { minDefenseIV } = req.query;
        const data = await appService.executeDefenseIVGroupBy(minDefenseIV ? parseInt(minDefenseIV) : null);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/aggregation/trainer-pokemon-count', async (req, res) => {
    try {
        const data = await appService.executeTrainerPokemonCount();
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// AGGREGATION WITH HAVING ENDPOINTS
router.get('/aggregation/highest-xp-having', async (req, res) => {
    try {
        const { minPokemonCount } = req.query;
        const data = await appService.executeHighestXPHaving(minPokemonCount ? parseInt(minPokemonCount) : 2);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/aggregation/trainers-multiple-pokemon', async (req, res) => {
    try {
        const { minXP } = req.query;
        const data = await appService.executeTrainersWithMultiplePokemon(minXP ? parseInt(minXP) : null);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// NESTED AGGREGATION ENDPOINTS
router.get('/aggregation/nested', async (req, res) => {
    try {
        const data = await appService.executeNestedAggregation();
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/aggregation/trainers-above-average', async (req, res) => {
    try {
        const data = await appService.executeTrainersAboveAverageXP();
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// DIVISION ENDPOINTS
router.post('/division/species-with-types', async (req, res) => {
    try {
        const { types } = req.body;
        const data = await appService.executeSpeciesWithAllTypes(types);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

router.get('/division/species-by-type-count', async (req, res) => {
    try {
        const { exactTypeCount } = req.query;
        const data = await appService.executeSpeciesByTypeCount(exactTypeCount ? parseInt(exactTypeCount) : null);
        res.json({ success: true, data });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

module.exports = router;
</file>

<file path="frontend/public/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Database Application</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <!-- CONNECTION STATUS -->
    <h1>Pokemon Database Connection Status:
        <span id="dbStatus"> </span>
        <img id="loadingGif" class="loading-gif" src="loading_100px.gif" alt="Loading...">
    </h1>

    <br>
    <hr><br>

    <!-- RESET THE DATABASE-->
    <h2>Reset Pokemon Database</h2>
    <p>Click reset to set up the Pokemon database. <strong>Use this first!</strong></p>
    <button id="resetDatabase">Reset Database</button>
    <div id="resetResultMsg"></div>

    <br>
    <hr><br>

    <!-- TRAINER -->
    <h2>Trainers</h2>
    <table id="trainersTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Name</th>
                <th>Location</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Insert New Trainer</h3>
    <form id="insertTrainer">
        Trainer ID: <input type="number" id="insertTrainerId" placeholder="Enter Trainer ID" min="1" required> <br><br>
        Name: <input type="text" id="insertTrainerName" placeholder="Enter Trainer Name" maxlength="255" required>
        <br><br>
        Location: <input type="text" id="insertTrainerLocation" placeholder="Enter Location (optional)" maxlength="40">
        <br><br>
        <button type="submit">Insert Trainer</button>
    </form>
    <div id="insertTrainerResultMsg"></div>

    <h3>Update Trainer</h3>
    <form id="updateTrainer">
        Trainer ID: <input type="number" id="updateTrainerId" placeholder="Enter Trainer ID to Update" min="1" required>
        <br><br>
        New Name: <input type="text" id="updateTrainerName" placeholder="Enter New Name (optional)" maxlength="255">
        <br><br>
        New Location: <input type="text" id="updateTrainerLocation" placeholder="Enter New Location (optional)"
            maxlength="40"> <br><br>
        <button type="submit">Update Trainer</button>
    </form>
    <div id="updateTrainerResultMsg"></div>

    <h3>Delete Trainer (Cascades to Player/Gym Leader)</h3>
    <form id="deleteTrainer">
        Trainer ID: <input type="number" id="deleteTrainerId" placeholder="Enter Trainer ID" min="1" required> <br><br>
        <button type="submit">Delete Trainer</button>
    </form>
    <div id="deleteTrainerResultMsg"></div>

    <br>
    <hr><br>

    <!-- PLAYER -->
    <h2>Players</h2>
    <table id="playersTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Money</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Turn Regular Trainer into a Player</h3>
    <form id="insertPlayer">
        Trainer ID: <input type="number" id="insertPlayerTrainerId" placeholder="Enter Trainer ID" min="1" required> <br><br>
        Money: <input type="number" id="insertPlayerMoney" placeholder="Enter Starting Money" min="0" required> <br><br>
        <button type="submit">Insert Player</button>
    </form>
    <div id="insertPlayerResultMsg"></div>

    <h3>Update Player Money</h3>
    <form id="updatePlayer">
        Trainer ID: <input type="number" id="updatePlayerTrainerId" placeholder="Enter Player's Trainer ID" min="1" required>
        <br><br>
        New Money: <input type="number" id="updatePlayerMoney" placeholder="Enter New Money Amount" min="0" required> <br><br>
        <button type="submit">Update Player</button>
    </form>
    <div id="updatePlayerResultMsg"></div>

    <br>
    <hr><br>

    <!-- POKEMON -->
    <h2>Pokemon</h2>
    <table id="pokemonTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Pokemon ID</th>
                <th>Name</th>
                <th>Level</th>
                <th>Nature</th>
                <th>HP IV</th>
                <th>Attack IV</th>
                <th>Defense IV</th>
                <th>Speed IV</th>
                <th>Ability ID</th>
                <th>Trainer ID</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Insert New Pokemon</h3>
    <form id="insertPokemon">
        Pokedex #: <input type="number" id="insertPokemonPokedex" placeholder="Enter Pokedex Number" min="1" required> <br><br>
        Pokemon ID: <input type="number" id="insertPokemonId" placeholder="Enter Pokemon ID" min="1" required> <br><br>
        Name: <input type="text" id="insertPokemonName" placeholder="Enter Pokemon Name" maxlength="20" required>
        <br><br>
        Total XP: <input type="number" id="insertPokemonXP" placeholder="Enter Total XP" required> <br><br>
        Nature: <input type="text" id="insertPokemonNature" placeholder="Enter Nature" maxlength="12" required> <br><br>
        HP IV: <input type="number" id="insertPokemonHPIV" placeholder="HP IV (0-31)" min="0" max="31" required>
        <br><br>
        Attack IV: <input type="number" id="insertPokemonAttackIV" placeholder="Attack IV (0-31)" min="0" max="31"
            required> <br><br>
        Defense IV: <input type="number" id="insertPokemonDefenseIV" placeholder="Defense IV (0-31)" min="0" max="31"
            required> <br><br>
        Speed IV: <input type="number" id="insertPokemonSpeedIV" placeholder="Speed IV (0-31)" min="0" max="31"
            required> <br><br>
        Ability ID: <input type="number" id="insertPokemonAbilityId" placeholder="Enter Ability ID" min="1" required> <br><br>
        Trainer ID: <input type="number" id="insertPokemonTrainerId" placeholder="Enter Trainer ID (optional)" min="1"> <br><br>
        <button type="submit">Insert Pokemon</button>
    </form>
    <div id="insertPokemonResultMsg"></div>

    <h3>Update Pokemon</h3>
    <form id="updatePokemon">
        Pokedex #: <input type="number" id="updatePokemonPokedex" placeholder="Pokemon Pokedex #" min="1" required> <br><br>
        Pokemon ID: <input type="number" id="updatePokemonId" placeholder="Pokemon ID" min="1" required> <br><br>
        New Name: <input type="text" id="updatePokemonName" placeholder="New Pokemon Name (optional)" maxlength="20">
        <br><br>
        New Total XP: <input type="number" id="updatePokemonXP" placeholder="New Total XP (optional)"> <br><br>
        New Nature: <input type="text" id="updatePokemonNature" placeholder="New Nature (optional)" maxlength="12">
        <br><br>
        New HP IV: <input type="number" id="updatePokemonHPIV" placeholder="New HP IV (optional)" min="0" max="31">
        <br><br>
        New Attack IV: <input type="number" id="updatePokemonAttackIV" placeholder="New Attack IV (optional)" min="0"
            max="31"> <br><br>
        New Defense IV: <input type="number" id="updatePokemonDefenseIV" placeholder="New Defense IV (optional)" min="0"
            max="31"> <br><br>
        New Speed IV: <input type="number" id="updatePokemonSpeedIV" placeholder="New Speed IV (optional)" min="0"
            max="31"> <br><br>
        New Ability ID: <input type="number" id="updatePokemonAbilityId" placeholder="New Ability ID (optional)" min="1">
        <br><br>
        New Trainer ID: <input type="number" id="updatePokemonTrainerId" placeholder="New Trainer ID (optional)" min="1">
        <br><br>
        <button type="submit">Update Pokemon</button>
    </form>
    <div id="updatePokemonResultMsg"></div>

    <h3>Delete Pokemon (Cascades to Learned Moves)</h3>
    <form id="deletePokemon">
        Pokedex #: <input type="number" id="deletePokemonPokedex" placeholder="Enter Pokedex Number" min="1" required> <br><br>
        Pokemon ID: <input type="number" id="deletePokemonId" placeholder="Enter Pokemon ID" min="1" required> <br><br>
        <button type="submit">Delete Pokemon</button>
    </form>
    <div id="deletePokemonResultMsg"></div>

    <br>
    <hr><br>

    <!-- MOVES LEARNED-->
    <h2>Pokemon Learned Moves</h2>
    <table id="learnedMovesTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Pokemon ID</th>
                <th>Move ID</th>
                <th>Pokemon Name</th>
                <th>Move Name</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Teach Pokemon a Move</h3>
    <form id="insertLearnedMove">
        Pokedex #: <input type="number" id="insertLearnedMovePokedex" placeholder="Enter Pokedex Number" min="1" required>
        <br><br>
        Pokemon ID: <input type="number" id="insertLearnedMovePokemonId" placeholder="Enter Pokemon ID" min="1" required>
        <br><br>
        Move ID: <input type="number" id="insertLearnedMoveId" placeholder="Enter Move ID" min="1" required> <br><br>
        <button type="submit">Teach Move</button>
    </form>
    <div id="insertLearnedMoveResultMsg"></div>

    <h3>Update Learned Move</h3>
    <form id="updateLearnedMove">
        Pokedex #: <input type="number" id="updateLearnedMovePokedex" placeholder="Pokemon Pokedex #" min="1" required> <br><br>
        Pokemon ID: <input type="number" id="updateLearnedMovePokemonId" placeholder="Pokemon ID" min="1" required> <br><br>
        Old Move ID: <input type="number" id="updateLearnedMoveOldId" placeholder="Current Move ID" min="1" required> <br><br>
        New Move ID: <input type="number" id="updateLearnedMoveNewId" placeholder="New Move ID" min="1" required> <br><br>
        <button type="submit">Update Move</button>
    </form>
    <div id="updateLearnedMoveResultMsg"></div>

    <h3>Remove Learned Move</h3>
    <form id="deleteLearnedMove">
        Pokedex #: <input type="number" id="deleteLearnedMovePokedex" placeholder="Pokemon Pokedex #" min="1" required> <br><br>
        Pokemon ID: <input type="number" id="deleteLearnedMovePokemonId" placeholder="Pokemon ID" min="1" required> <br><br>
        Move ID: <input type="number" id="deleteLearnedMoveId" placeholder="Move ID to Remove" min="1" required> <br><br>
        <button type="submit">Remove Move</button>
    </form>
    <div id="deleteLearnedMoveResultMsg"></div>

    <br>
    <hr><br>

    <!-- SELECTION -->
    <h2>Selection Query on Pokemon</h2>
    <p>Create a query to filter Pokemon based on specific criteria. Add multiple conditions using AND/OR logic.</p>
    <form id="selectionQueryForm">
        <div id="conditionsContainer">
            <!-- Conditions added here dynamically -->
        </div>
        <br>
        <button type="button" id="addConditionBtn">Add Condition</button>
        <button type="submit">Run Selection Query</button>
    </form>
    <div id="selectionResultMsg"></div>
    <table id="selectionResultTable" border="1">
        <thead></thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- PROJECTION -->
    <h2>Projection Query</h2>
    <p>Select specific attributes from any table in the database.</p>
    <form id="projectionQuery">
        <label for="tableSelect">Select Table:</label>
        <select id="tableSelect" required>
            <option value="" disabled selected>Select a table</option>
        </select>
        <br><br>
        <div id="attributeCheckboxes"></div>
        <br>
        <button type="submit">Run Projection Query</button>
    </form>
    <div id="projectionResultMsg"></div>
    <table id="projectionResultTable" border="1">
        <thead></thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- JOIN -->
    <h2>Join Query: Species Located In</h2>
    <p>Find Pokemon species and their locations (or all species in a certain location) using JOIN operation.</p>
    <form id="joinQueryForm">
        <label for="locationFilter">Filter by Location (optional):</label>
        <select id="locationFilter">
            <option value="">All Locations</option>
        </select>
        <br><br>
        <button type="submit">Run Join Query</button>
    </form>
    <div id="joinResultMsg"></div>
    <table id="joinResultTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Species Name</th>
                <th>Description</th>
                <th>Location</th>
                <th>Climate</th>
                <th>Terrain Type</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- AGGREGATION WITH GROUP BY -->
    <h2>Aggregation with GROUP BY</h2>
    <p>Group Pokemon by trainer and analyze statistics.</p>
    
    <h3>Pokemon Defense IV by Trainer</h3>
    <form id="defenseIVForm">
        <label for="minDefenseIV">Minimum Defense IV (optional):</label>
        <input type="number" id="minDefenseIV" placeholder="Enter minimum Defense IV" min="0" max="31">
        <br><br>
        <button type="submit">Show Pokemon by Defense IV</button>
    </form>
    <div id="defenseIVResultMsg"></div>
    <table id="defenseIVTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Pokemon Name</th>
                <th>Defense IV</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Trainer Pokemon Statistics</h3>
    <button id="trainerStatsBtn">Show Trainer Statistics</button>
    <div id="trainerStatsResultMsg"></div>
    <table id="trainerStatsTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Pokemon Count</th>
                <th>Average Defense IV</th>
                <th>Max Defense IV</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- AGGREGATION WITH HAVING-->
    <h2>Aggregation with HAVING</h2>
    <p>Find trainers with multiple Pokemon and analyze their highest XP Pokemon.</p>
    
    <h3>Trainers with Highest XP Pokemon (Having Multiple Pokemon)</h3>
    <form id="highestXPForm">
        <label for="minPokemonCount">Minimum Pokemon Count:</label>
        <input type="number" id="minPokemonCount" value="2" min="1" max="10" required>
        <br><br>
        <button type="submit">Find Trainers with High XP Pokemon</button>
    </form>
    <div id="highestXPResultMsg"></div>
    <table id="highestXPTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Highest XP</th>
                <th>Pokemon Count</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Trainers with Multiple Pokemon - Detailed Stats</h3>
    <form id="multiplePokemonForm">
        <label for="minXPFilter">Minimum XP Filter (optional):</label>
        <input type="number" id="minXPFilter" placeholder="Enter minimum XP">
        <br><br>
        <button type="submit">Show Detailed Trainer Stats</button>
    </form>
    <div id="multiplePokemonResultMsg"></div>
    <table id="multiplePokemonTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Pokemon Count</th>
                <th>Average XP</th>
                <th>Max XP</th>
                <th>Min XP</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- NESTED AGGREGATION WITH GROUP BY -->
    <h2>Nested Aggregation with GROUP BY</h2>
    <p>Complex aggregation queries with nested subqueries.</p>
    
    <h3>Trainers with Above-Average Pokemon XP</h3>
    <button id="nestedAggregationBtn">Find Trainers Above Average XP</button>
    <div id="nestedAggregationResultMsg"></div>
    <table id="nestedAggregationTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Pokemon Count</th>
                <th>Average XP</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Detailed Above-Average Analysis</h3>
    <button id="aboveAverageBtn">Show Detailed Above-Average Analysis</button>
    <div id="aboveAverageResultMsg"></div>
    <table id="aboveAverageTable" border="1">
        <thead>
            <tr>
                <th>Trainer ID</th>
                <th>Trainer Name</th>
                <th>Pokemon Count</th>
                <th>Trainer Avg XP</th>
                <th>Global Avg XP</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- DIVISION -->
    <h2>Division Query: Species Has Type</h2>
    <p>Find all species that have specific types or combinations of types.</p>
    
    <h3>Find Species with Specific Types (Division)</h3>
    <form id="divisionQueryForm">
        <label>Select Types (species must have ALL selected types):</label><br>
        <div id="typeCheckboxes" style="margin: 10px 0;">
            <!-- Type checkboxes will be populated here -->
        </div>
        <br>
        <button type="submit">Find Species with Selected Types</button>
        <button type="button" id="showAllSpeciesTypesBtn">Show All Species and Their Types</button>
    </form>
    <div id="divisionResultMsg"></div>
    <table id="divisionResultTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Species Name</th>
                <th>Types</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Species by Type Count</h3>
    <form id="typeCountForm">
        <label for="exactTypeCount">Exact Type Count (optional):</label>
        <select id="exactTypeCount">
            <option value="">All Type Counts</option>
            <option value="1">Exactly 1 Type</option>
            <option value="2">Exactly 2 Types</option>
        </select>
        <br><br>
        <button type="submit">Filter by Type Count</button>
    </form>
    <div id="typeCountResultMsg"></div>
    <table id="typeCountTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Species Name</th>
                <th>Type Count</th>
                <th>Types</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br>
    <hr><br>

    <!-- REFERENCE TABLES -->
    <h2>Reference Data</h2>

    <h3>Available Pokemon Species</h3>
    <table id="speciesTable" border="1">
        <thead>
            <tr>
                <th>Pokedex #</th>
                <th>Species Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Available Moves</h3>
    <table id="movesTable" border="1">
        <thead>
            <tr>
                <th>Move ID</th>
                <th>Move Name</th>
                <th>Type</th>
                <th>Power</th>
                <th>PP</th>
                <th>Accuracy</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Available Abilities</h3>
    <table id="abilitiesTable" border="1">
        <thead>
            <tr>
                <th>Ability ID</th>
                <th>Ability Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h3>Available Natures</h3>
    <table id="naturesTable" border="1">
        <thead>
            <tr>
                <th>Nature</th>
                <th>Stat Increased</th>
                <th>Stat Decreased</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script src="scripts.js"></script>
</body>

</html>
</file>

<file path="database/insert_data.sql">
INSERT INTO Location (name, climate, terrain_type) VALUES ('Pallet Town', 'Temperate', 'Grassland');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Viridian City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Pewter City', 'Mountainous', 'Rocky');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Cerulean City', 'Coastal', 'Beach');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Vermilion City', 'Coastal', 'Port');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Celadon City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Fuchsia City', 'Tropical', 'Swamp');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Saffron City', 'Temperate', 'Urban');
INSERT INTO Location (name, climate, terrain_type) VALUES ('Route 1', 'Temperate', 'Grassland');

INSERT INTO Type (name, colour) VALUES ('Normal', 'Tan');
INSERT INTO Type (name, colour) VALUES ('Fire', 'Red');
INSERT INTO Type (name, colour) VALUES ('Water', 'Blue');
INSERT INTO Type (name, colour) VALUES ('Electric', 'Yellow');
INSERT INTO Type (name, colour) VALUES ('Grass', 'Green');
INSERT INTO Type (name, colour) VALUES ('Ice', 'Light Blue');
INSERT INTO Type (name, colour) VALUES ('Fighting', 'Brown');
INSERT INTO Type (name, colour) VALUES ('Poison', 'Purple');
INSERT INTO Type (name, colour) VALUES ('Ground', 'Earth');
INSERT INTO Type (name, colour) VALUES ('Flying', 'Sky Blue');
INSERT INTO Type (name, colour) VALUES ('Psychic', 'Pink');
INSERT INTO Type (name, colour) VALUES ('Bug', 'Olive');
INSERT INTO Type (name, colour) VALUES ('Rock', 'Gray');
INSERT INTO Type (name, colour) VALUES ('Ghost', 'Indigo');
INSERT INTO Type (name, colour) VALUES ('Dragon', 'Dark Blue');
INSERT INTO Type (name, colour) VALUES ('Dark', 'Black');
INSERT INTO Type (name, colour) VALUES ('Steel', 'Silver');
INSERT INTO Type (name, colour) VALUES ('Fairy', 'Light Pink');

INSERT INTO Badge (badge_index, name) VALUES (1, 'Boulder Badge');
INSERT INTO Badge (badge_index, name) VALUES (2, 'Cascade Badge');
INSERT INTO Badge (badge_index, name) VALUES (3, 'Thunder Badge');
INSERT INTO Badge (badge_index, name) VALUES (4, 'Rainbow Badge');
INSERT INTO Badge (badge_index, name) VALUES (5, 'Soul Badge');
INSERT INTO Badge (badge_index, name) VALUES (6, 'Marsh Badge');

INSERT INTO Ability (ability_id, name, description) VALUES (2, 'Static', 'Contact with the Pokémon may cause paralysis.');
INSERT INTO Ability (ability_id, name, description) VALUES (4, 'Overgrow', 'Powers up Grass-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (5, 'Blaze', 'Powers up Fire-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (6, 'Torrent', 'Powers up Water-type moves when the Pokémon''s HP is low.');
INSERT INTO Ability (ability_id, name, description) VALUES (8, 'Chlorophyll', 'Boosts the Pokémon''s Speed stat in harsh sunlight.');
INSERT INTO Ability (ability_id, name, description) VALUES (9, 'Solar Power', 'Boosts the Sp. Atk stat in harsh sunlight, but HP decreases every turn.');
INSERT INTO Ability (ability_id, name, description) VALUES (10, 'Rain Dish', 'The Pokémon gradually regains HP in rain.');
INSERT INTO Ability (ability_id, name, description) VALUES (11, 'Lightning Rod', 'Draws in all Electric-type moves to boost its Sp. Atk stat.');

INSERT INTO Species (pokedex, name, description) VALUES (1, 'Bulbasaur', 'It carries a seed on its back right from birth. As its body grows larger, the seed does too.');
INSERT INTO Species (pokedex, name, description) VALUES (2, 'Ivysaur', 'The bulb on its back grows as it absorbs nutrients. The bulb gives off a pleasant aroma when it blooms.');
INSERT INTO Species (pokedex, name, description) VALUES (3, 'Venusaur', 'By spreading the broad petals of its flower and catching the sun''s rays, it fills its body with power.');
INSERT INTO Species (pokedex, name, description) VALUES (4, 'Charmander', 'The flame on its tail shows the strength of its life-force. If Charmander is weak, the flame also burns weakly.');
INSERT INTO Species (pokedex, name, description) VALUES (5, 'Charmeleon', 'It is very hotheaded by nature, so it constantly seeks opponents to battle against. Its aggression will not be quelled if it doesn''t win.');
INSERT INTO Species (pokedex, name, description) VALUES (6, 'Charizard', 'The flame inside its body burns hotter than 3,600 degrees Fahrenheit. When Charizard roars, that temperature climbs even higher.');
INSERT INTO Species (pokedex, name, description) VALUES (7, 'Squirtle', 'Its shell is soft immediately after it is born. In no time at all, the shell becomes so resilient that a prodding finger will bounce right off it.');
INSERT INTO Species (pokedex, name, description) VALUES (8, 'Wartortle', 'It often hides in water to stalk unwary prey. While swimming quickly, it moves its ears to maintain balance.');
INSERT INTO Species (pokedex, name, description) VALUES (9, 'Blastoise', 'It has jet nozzles on its shell. This impressive Pokémon uses these jets to charge toward foes with all the force of a rocket.');
INSERT INTO Species (pokedex, name, description) VALUES (25, 'Pikachu', 'When several of these Pokémon gather, their electricity can build and cause lightning storms.');
INSERT INTO Species (pokedex, name, description) VALUES (26, 'Raichu', 'Its tail discharges electricity into the ground, protecting it from getting shocked.');

INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (1, 'Mineral', 'Pokemon in this group are inorganic in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (2, 'Amorphous', 'Pokemon in this group are amorphous, having no definite form');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (3, 'Grass', 'Pokemon in this group are plantlike in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (4, 'Water 3', 'Pokemon in this group resemble aquatic invertebrates');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (5, 'Water 2', 'Pokemon in this group are piscine (fishlike) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (6, 'Water 1', 'Pokemon in this group are amphibious in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (7, 'Bug', 'Pokemon in this group are insectoid (bug-like) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (8, 'Dragon', 'Pokemon in this group are reptilian or draconic in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (9, 'Flying', 'Pokemon in this group are avian (birdlike) in appearance');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (10, 'Field', 'The largest group, Pokemon here are terrestrial in nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (11, 'Human-Like', 'Pokemon in this group are fully bipedal humanoids');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (12, 'Fairy', 'Pokemon in this group are petite and considered very cute');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (13, 'Monster', 'Pokemon in this group are saurian/kaiju-like in appearance and nature');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (14, 'Ditto', 'Ditto is the only Pokemon in this group, capable of breeding with most others');
INSERT INTO Egg_Group (egg_group_id, name, description) VALUES (15, 'No Eggs Discovered', 'Pokemon in this group are unable to breed');

INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (1, 'Tackle', 40, 35, 100, 'A physical attack in which the user charges and slams INSERT INTO the target with its whole body.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (2, 'Growl', 0, 40, 100, 'The user growls in an endearing way, making opposing Pokémon less wary and lowering their Attack stats.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (3, 'Vine Whip', 45, 25, 100, 'The target is struck with slender, whip-like vines.', 'Grass');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (4, 'Ember', 40, 25, 100, 'The target is attacked with small flames. May also leave the target with a burn.', 'Fire');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (5, 'Flamethrower', 90, 15, 100, 'The target is scorched with an intense blast of fire. May also leave the target with a burn.', 'Fire');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (6, 'Water Gun', 40, 25, 100, 'The target is blasted with a forceful jet of water.', 'Water');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (7, 'Hydro Pump', 110, 5, 80, 'The target is blasted by a huge volume of water launched under great pressure.', 'Water');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (8, 'Thunder Shock', 40, 30, 100, 'A jolt of electricity is hurled at the target to inflict damage. May also paralyze the target.', 'Electric');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (9, 'Quick Attack', 40, 30, 100, 'The user lunges at the target at a speed that makes it almost invisible.', 'Normal');
INSERT INTO Move (move_id, name, power, pp, accuracy, description, type_name) VALUES (10, 'Double Team', 0, 15, 0, 'By moving rapidly, the user makes illusory copies of itself to raise its evasion.', 'Normal');

INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Adamant', 'Attack', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Modest', 'Sp. Atk', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Jolly', 'Speed', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Timid', 'Speed', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Bold', 'Defense', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Impish', 'Defense', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Calm', 'Sp. Def', 'Attack');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Careful', 'Sp. Def', 'Sp. Atk');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Naive', 'Speed', 'Sp. Def');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Hasty', 'Speed', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Brave', 'Attack', 'Speed');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Quiet', 'Sp. Atk', 'Speed');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Rash', 'Sp. Atk', 'Sp. Def');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Lonely', 'Attack', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Mild', 'Sp. Atk', 'Defense');
INSERT INTO Pokemon_2 (nature, stat_increased, stat_decreased) VALUES ('Relaxed', 'Defense', 'Speed');

INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (1, 0);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (2, 250);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (3, 500);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (4, 750);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (5, 1000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (6, 1400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (7, 1800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (8, 2200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (9, 2600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (10, 3000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (11, 3600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (12, 4200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (13, 4800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (14, 5400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (15, 6000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (16, 6800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (17, 7600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (18, 8400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (19, 9200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (20, 10000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (21, 11000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (22, 12000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (23, 13000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (24, 14000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (25, 15000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (26, 16200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (27, 17400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (28, 18600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (29, 19800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (30, 21000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (31, 22400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (32, 23800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (33, 25200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (34, 26600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (35, 28000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (36, 29600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (37, 31200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (38, 32800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (39, 34400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (40, 36000);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (41, 37800);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (42, 39600);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (43, 41400);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (44, 43200);
INSERT INTO Pokemon_3 (pokemon_level, total_XP) VALUES (45, 45000);

INSERT INTO Item_2 (price, rarity) VALUES (0, 'Quest');
INSERT INTO Item_2 (price, rarity) VALUES (100, 'Common');
INSERT INTO Item_2 (price, rarity) VALUES (200, 'Common');
INSERT INTO Item_2 (price, rarity) VALUES (600, 'Uncommon');
INSERT INTO Item_2 (price, rarity) VALUES (1000, 'Rare');
INSERT INTO Item_2 (price, rarity) VALUES (2500, 'Very Rare');

INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (1, 1000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (2, 2000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (3, 3000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (4, 5000);
INSERT INTO Gym_Leader_2 (difficulty, cash_reward) VALUES (5, 10000);

INSERT INTO Trainer (trainer_id, name, location_name) VALUES (1, 'Ash', 'Pallet Town');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (2, 'Gary', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (3, 'Brock', 'Pewter City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (4, 'Misty', 'Cerulean City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (5, 'Lt. Surge', 'Vermilion City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (6, 'Erika', 'Celadon City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (7, 'Koga', 'Fuchsia City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (8, 'Sabrina', 'Saffron City');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (9, 'Blaine', 'Route 1');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (10, 'Giovanni', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (11, 'John', 'Pallet Town');
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (12, 'Joe', NULL);
INSERT INTO Trainer (trainer_id, name, location_name) VALUES (13, 'Amanda', NULL);

INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Poké Ball', 'A ball thrown to catch a wild Pokémon. It has a 1x catch rate.', 100, 'Viridian City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Potion', 'A spray-type medicine for treating wounds. It restores the HP of one Pokémon by 20 points.', 200, 'Viridian City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Super Potion', 'A spray-type medicine for treating wounds. It restores the HP of one Pokémon by 50 points.', 600, 'Cerulean City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('TM28 - Dig', 'A TM that teaches the move Dig to a compatible Pokémon.', 1000, 'Vermilion City');
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Rare Candy', 'A candy that is packed with energy. When consumed, it will instantly raise the level of a single Pokémon by one.', 2500, NULL);
INSERT INTO Item_1 (name, description, price, location_name) VALUES ('Bicycle', 'A folding Bicycle that enables a rider to get around much faster than with Running Shoes.', 0, 'Cerulean City');

INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (1, 1, 'Bulbasaur', 1000, 'Modest', 25, 15, 20, 18, 4, 1);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (2, 1, 'Ivysaur', 3000, 'Calm', 28, 18, 25, 20, 4, 1);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (3, 1, 'Venusaur', 6000, 'Bold', 31, 20, 31, 22, 4, 2);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (4, 1, 'Charmander', 1000, 'Jolly', 22, 25, 18, 28, 5, 3);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (5, 1, 'Charmeleon', 3000, 'Adamant', 26, 30, 20, 25, 5, 4);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (6, 1, 'Charizard', 6000, 'Adamant', 31, 31, 22, 28, 5, 5);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (7, 1, 'Squirtle', 1000, 'Bold', 24, 18, 28, 20, 6, 5);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (8, 1, 'Wartortle', 3000, 'Relaxed', 28, 20, 30, 18, 6, 6);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (9, 1, 'Blastoise', 6000, 'Modest', 31, 15, 31, 25, 6, 7);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (25, 1, 'Pikachu', 3000, 'Timid', 20, 18, 15, 31, 2, 8);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (25, 2, 'Pikachu', 1000, 'Relaxed', 1, 31, 9, 6, 11, 8);
INSERT INTO Pokemon_1 (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) VALUES (26, 1, 'Raichu', 6000, 'Jolly', 25, 25, 20, 31, 2, 9);

INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (3, 1, 'Rock', 1);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (4, 2, 'Water', 2);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (5, 3, 'Electric', 3);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (6, 4, 'Grass', 4);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (7, 5, 'Poison', 5);
INSERT INTO Gym_Leader_1 (trainer_id, difficulty, specialty_type_name, badge_index) VALUES (8, 5, 'Psychic', 6);

INSERT INTO Player (trainer_id, money) VALUES (1, 5000);
INSERT INTO Player (trainer_id, money) VALUES (2, 3000);
INSERT INTO Player (trainer_id, money) VALUES (11, 5000);
INSERT INTO Player (trainer_id, money) VALUES (12, 3000);
INSERT INTO Player (trainer_id, money) VALUES (13, 5000);

INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (1, 2, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (2, 3, 32);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (4, 5, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (5, 6, 36);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (7, 8, 16);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (8, 9, 36);
INSERT INTO Species_Evolves_Into (old_pokedex, new_pokedex, evolution_level) VALUES (25, 26, NULL);

INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (1, 1, 3);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (4, 1, 4);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 2);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (7, 1, 6);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 1, 1);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 1, 8);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (25, 2, 9);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (26, 1, 8);
INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (26, 1, 9);

INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (1, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (1, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (2, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (2, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (3, 'Grass');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (3, 'Poison');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (4, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (5, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (6, 'Fire');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (6, 'Flying');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (7, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (8, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (9, 'Water');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (25, 'Electric');
INSERT INTO Species_Has_Type (pokedex, type_name) VALUES (26, 'Electric');

INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (1, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (2, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 3);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (3, 2);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (4, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (4, 4);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (5, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (5, 5);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (6, 5);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (6, 9);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (7, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (7, 6);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (8, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (8, 6);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (9, 1);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (9, 7);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 8);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 9);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (25, 10);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (26, 8);
INSERT INTO Species_Can_Learn_Move (pokedex, move_id) VALUES (26, 9);

INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (1, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (1, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (2, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (2, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (3, 4);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (3, 8);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (4, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (4, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (5, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (5, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (6, 5);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (6, 9);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (7, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (7, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (8, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (8, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (9, 6);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (9, 10);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (25, 2);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (25, 11);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (26, 2);
INSERT INTO Species_Can_Have_Ability (pokedex, ability_id) VALUES (26, 11);

INSERT INTO Species_Located_In (pokedex, location_name) VALUES (1, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (4, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (7, 'Pallet Town');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (25, 'Viridian City');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (25, 'Vermilion City');
INSERT INTO Species_Located_In (pokedex, location_name) VALUES (26, 'Vermilion City');

INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (1, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (1, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (2, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (2, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (3, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (3, 3);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (4, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (4, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (5, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (5, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (6, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (6, 8);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (7, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (7, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (8, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (8, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (9, 13);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (9, 6);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (25, 10);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (25, 12);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (26, 10);
INSERT INTO Species_Belongs_To_Egg_Group (pokedex, egg_group_id) VALUES (26, 12);

INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 1);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 2);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 3);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (1, 4);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (2, 1);
INSERT INTO Player_Owns_Badge (trainer_id, badge_index) VALUES (2, 2);
</file>

<file path="frontend/appService.js">
const oracledb = require('oracledb');
const loadEnvFile = require('./utils/envUtil');
const fs = require('fs');
const path = require('path');

const envVariables = loadEnvFile('./.env');

// Database configuration setup. Ensure your .env file has the required database credentials.

const dbConfig = {
    user: envVariables.ORACLE_USER,
    password: envVariables.ORACLE_PASS,
    connectString: `${envVariables.ORACLE_HOST}:${envVariables.ORACLE_PORT}/${envVariables.ORACLE_DBNAME}`,
    poolMin: 1,
    poolMax: 3,
    poolIncrement: 1,
    poolTimeout: 60
};

// INPUT VALIDATION 
function validateInteger(value, fieldName, options = {}) {
    if (value === null || value === undefined || value === '') {
        if (options.required) {
            throw new Error(`${fieldName} is required`);
        }
        return options.allowNull ? null : undefined;
    }

    const num = parseInt(value);
    if (isNaN(num) || num.toString() !== value.toString()) {
        throw new Error(`${fieldName} must be a valid integer`);
    }

    if (options.min !== undefined && num < options.min) {
        throw new Error(`${fieldName} must be at least ${options.min}`);
    }

    if (options.max !== undefined && num > options.max) {
        throw new Error(`${fieldName} must be at most ${options.max}`);
    }

    return num;
}

function validateString(value, fieldName, options = {}) {
    if (!value || value.trim() === '') {
        if (options.required) {
            throw new Error(`${fieldName} is required`);
        }
        return options.allowNull ? null : '';
    }

    if (typeof value !== 'string') {
        throw new Error(`${fieldName} must be a string`);
    }

    value = value.trim();

    // Remove potential XSS
    value = value.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    value = value.replace(/[<>]/g, '');

    // Check SQL injection patterns
    const sqlPatterns = [
        /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/gi,
        /(-{2}|\/\*|\*\/)/g,
        /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
        /(WAITFOR|DELAY|SLEEP|BENCHMARK|INFORMATION_SCHEMA)/gi,
        /(UNION\s+(ALL\s+)?SELECT)/gi,
        /(\bEXEC\s*\()/gi
    ];

    for (const pattern of sqlPatterns) {
        if (pattern.test(value)) {
            throw new Error(`Invalid characters detected in ${fieldName}`);
        }
    }

    if (options.maxLength && value.length > options.maxLength) {
        throw new Error(`${fieldName} must be ${options.maxLength} characters or less`);
    }

    if (options.pattern && !options.pattern.test(value)) {
        throw new Error(`${fieldName} contains invalid characters`);
    }

    return value;
}

function validateTableName(tableName) {
    const validTables = [
        'TRAINER', 'PLAYER', 'POKEMON_1', 'POKEMON_2', 'POKEMON_3',
        'SPECIES', 'MOVE', 'ABILITY', 'TYPE', 'LOCATION', 'BADGE',
        'EGG_GROUP', 'ITEM_1', 'ITEM_2', 'GYM_LEADER_1', 'GYM_LEADER_2',
        'SPECIES_EVOLVES_INTO', 'POKEMON_HAS_LEARNED_MOVE', 'SPECIES_HAS_TYPE',
        'SPECIES_CAN_LEARN_MOVE', 'SPECIES_CAN_HAVE_ABILITY', 'SPECIES_LOCATED_IN',
        'SPECIES_BELONGS_TO_EGG_GROUP', 'PLAYER_OWNS_BADGE'
    ];

    const upperTableName = tableName.toUpperCase();
    if (!validTables.includes(upperTableName)) {
        throw new Error('Invalid table name');
    }

    return upperTableName;
}

function validateColumnName(tableName, columnName) {
    const validColumns = {
        'TRAINER': ['TRAINER_ID', 'NAME', 'LOCATION_NAME'],
        'PLAYER': ['TRAINER_ID', 'MONEY'],
        'POKEMON_1': ['POKEDEX', 'POKEMON_ID', 'NAME', 'TOTAL_XP', 'NATURE', 'HP_IV', 'ATTACK_IV', 'DEFENSE_IV', 'SPEED_IV', 'ABILITY_ID', 'TRAINER_ID'],
        'POKEMON_2': ['NATURE', 'STAT_INCREASED', 'STAT_DECREASED'],
        'POKEMON_3': ['TOTAL_XP', 'POKEMON_LEVEL'],
        'SPECIES': ['POKEDEX', 'NAME', 'DESCRIPTION'],
        'MOVE': ['MOVE_ID', 'NAME', 'POWER', 'PP', 'ACCURACY', 'DESCRIPTION', 'TYPE_NAME'],
        'ABILITY': ['ABILITY_ID', 'NAME', 'DESCRIPTION'],
        'TYPE': ['NAME', 'COLOUR'],
        'LOCATION': ['NAME', 'CLIMATE', 'TERRAIN_TYPE'],
        'BADGE': ['BADGE_INDEX', 'NAME'],
        'EGG_GROUP': ['EGG_GROUP_ID', 'NAME', 'DESCRIPTION'],
        'ITEM_1': ['NAME', 'DESCRIPTION', 'PRICE', 'LOCATION_NAME'],
        'ITEM_2': ['PRICE', 'RARITY'],
        'GYM_LEADER_1': ['TRAINER_ID', 'DIFFICULTY', 'SPECIALTY_TYPE_NAME', 'BADGE_INDEX'],
        'GYM_LEADER_2': ['DIFFICULTY', 'CASH_REWARD'],
        'SPECIES_EVOLVES_INTO': ['OLD_POKEDEX', 'NEW_POKEDEX', 'EVOLUTION_LEVEL'],
        'POKEMON_HAS_LEARNED_MOVE': ['POKEDEX', 'POKEMON_ID', 'MOVE_ID'],
        'SPECIES_HAS_TYPE': ['POKEDEX', 'TYPE_NAME'],
        'SPECIES_CAN_LEARN_MOVE': ['POKEDEX', 'MOVE_ID'],
        'SPECIES_CAN_HAVE_ABILITY': ['POKEDEX', 'ABILITY_ID'],
        'SPECIES_LOCATED_IN': ['POKEDEX', 'LOCATION_NAME'],
        'SPECIES_BELONGS_TO_EGG_GROUP': ['POKEDEX', 'EGG_GROUP_ID'],
        'PLAYER_OWNS_BADGE': ['TRAINER_ID', 'BADGE_INDEX']
    };

    const upperTableName = tableName.toUpperCase();
    const upperColumnName = columnName.toUpperCase();

    if (!validColumns[upperTableName] || !validColumns[upperTableName].includes(upperColumnName)) {
        throw new Error(`Invalid column name ${columnName} for table ${tableName}`);
    }

    return upperColumnName;
}

function validateOperator(operator) {
    const validOperators = ['=', '!=', '>', '<', '>=', '<=', 'LIKE'];
    if (!validOperators.includes(operator)) {
        throw new Error('Invalid operator');
    }
    return operator;
}

function validatePokemonAttribute(attribute) {
    const validAttributes = ['pokedex', 'pokemon_id', 'name', 'total_XP', 'nature', 'HP_IV', 'attack_IV', 'defense_IV', 'speed_IV', 'ability_id', 'trainer_id'];
    if (!validAttributes.includes(attribute)) {
        throw new Error('Invalid Pokemon attribute');
    }
    return attribute;
}

function validateLogicalOperator(operator) {
    const validLogical = ['AND', 'OR'];
    if (!validLogical.includes(operator)) {
        return 'AND'; // AND is safest
    }
    return operator;
}

function validateNature(nature) {
    const validNatures = [
        'Adamant', 'Modest', 'Jolly', 'Timid', 'Bold', 'Impish',
        'Calm', 'Careful', 'Naive', 'Hasty', 'Brave', 'Quiet',
        'Rash', 'Lonely', 'Mild', 'Relaxed'
    ];

    if (!validNatures.includes(nature)) {
        throw new Error('Invalid Pokemon nature');
    }

    return nature;
}

// initialize connection pool
async function initializeConnectionPool() {
    try {
        await oracledb.createPool(dbConfig);
        console.log('Connection pool started');
    } catch (err) {
        console.error('Initialization error: ' + err.message);
    }
}

async function closePoolAndExit() {
    console.log('\nTerminating');
    try {
        await oracledb.getPool().close(10); // 10 seconds grace period for connections to finish
        console.log('Pool closed');
        process.exit(0);
    } catch (err) {
        console.error(err.message);
        process.exit(1);
    }
}

initializeConnectionPool();

process
    .once('SIGTERM', closePoolAndExit)
    .once('SIGINT', closePoolAndExit);

// ----------------------------------------------------------
// Wrapper to manage OracleDB actions, simplifying connection handling.
async function withOracleDB(action) {
    let connection;
    try {
        connection = await oracledb.getConnection(); // Gets a connection from the default pool 
        return await action(connection);
    } catch (err) {
        console.error(err);
        throw err;
    } finally {
        if (connection) {
            try {
                await connection.close();
            } catch (err) {
                console.error(err);
            }
        }
    }
}

// ----------------------------------------------------------
// Core functions for database operations
// Modify these functions, especially the SQL queries, based on your project's requirements and design.
async function testOracleConnection() {
    return await withOracleDB(async (connection) => {
        return true;
    }).catch(() => {
        return false;
    });
}

async function initiatePokemonDB() {
    return await withOracleDB(async (connection) => {
        try {
            // Read SQL files
            const resetSQL = fs.readFileSync(path.join(__dirname, '../database/reset.sql'), 'utf8');
            const createSQL = fs.readFileSync(path.join(__dirname, '../database/create_pokemon_db.sql'), 'utf8');
            const insertSQL = fs.readFileSync(path.join(__dirname, '../database/insert_data.sql'), 'utf8');

            // Execute reset (drop tables)
            console.log('Dropping existing tables...');
            const resetBlocks = resetSQL.split('/').filter(block => block.trim());
            for (const block of resetBlocks) {
                if (block.trim() && !block.trim().startsWith('PURGE')) {
                    try {
                        await connection.execute(block.trim());
                    } catch (err) {
                        console.log('Reset block failed (may be normal):', err.message);
                    }
                }
            }

            try {
                await connection.execute('PURGE RECYCLEBIN');
            } catch (err) {
                console.log('Purge recyclebin failed (may be normal):', err.message);
            }

            await connection.commit();
            console.log('Committed drops');

            // Execute create tables
            console.log('Creating tables...');
            const createStatements = createSQL.split(';').filter(stmt => stmt.trim());
            let tableCount = 0;
            for (const statement of createStatements) {
                if (statement.trim()) {
                    try {
                        await connection.execute(statement.trim());
                        tableCount++;
                        console.log(`Created table ${tableCount}`);
                    } catch (err) {
                        console.error('Error creating table:', err.message);
                    }
                }
            }
            console.log(`Total tables created: ${tableCount}`);

            await connection.commit();
            console.log('Committed table creation');

            // Execute inserts
            console.log('Inserting data...');
            const insertStatements = insertSQL.split(';').filter(stmt => {
                const trimmed = stmt.trim();
                return trimmed && trimmed.toLowerCase().startsWith('insert');
            });

            console.log(`Found ${insertStatements.length} insert statements`);

            let successfulInserts = 0;
            for (let i = 0; i < insertStatements.length; i++) {
                const statement = insertStatements[i].trim();
                if (statement) {
                    try {
                        await connection.execute(statement);
                        successfulInserts++;
                        if (successfulInserts % 10 === 0) {
                            console.log(`Successfully executed ${successfulInserts} insert statements...`);
                        }
                    } catch (err) {
                        console.error(`Insert statement ${i + 1} failed:`, err.message);
                        console.error('Statement:', statement.substring(0, 100) + '...');
                    }
                }
            }

            await connection.commit();
            console.log('Committed all inserts');

            console.log(`Successfully executed ${successfulInserts} out of ${insertStatements.length} insert statements`);

            // Verify data insertion
            try {
                const testResult = await connection.execute('SELECT COUNT(*) FROM Trainer');
                console.log('Trainers in database after insert:', testResult.rows[0][0]);
            } catch (err) {
                console.error('Error checking trainer count:', err.message);
            }

            try {
                const testResult2 = await connection.execute('SELECT COUNT(*) FROM Pokemon_1');
                console.log('Pokemon in database after insert:', testResult2.rows[0][0]);
            } catch (err) {
                console.error('Error checking pokemon count:', err.message);
            }

            console.log('Pokemon database setup complete!');
            return true;
        } catch (err) {
            console.error('Error setting up Pokemon database:', err);
            try {
                await connection.rollback();
                console.log('Rolled back due to error');
            } catch (rollbackErr) {
                console.error('Error during rollback:', rollbackErr);
            }
            return false;
        }
    }).catch((err) => {
        console.error('Database connection error:', err);
        return false;
    });
}

// FETCH FUNCTIONS
async function fetchFromDb(query) {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(query);
        return result.rows;
    }).catch((err) => {
        console.error('Error in fetching:', err);
        return [];
    });
}

async function fetchTrainersFromDb() {
    return await fetchFromDb('SELECT * FROM Trainer ORDER BY trainer_id');
}

async function fetchPlayersFromDb() {
    return await fetchFromDb(`
        SELECT p.trainer_id, t.name, p.money 
        FROM Player p, Trainer t
        WHERE p.trainer_id = t.trainer_id 
        ORDER BY p.trainer_id
    `);
}

async function fetchPokemonFromDb() {
    return await fetchFromDb(`
        SELECT p1.pokedex, p1.pokemon_id, p1.name, p3.pokemon_level, p1.nature, 
               p1.HP_IV, p1.attack_IV, p1.defense_IV, p1.speed_IV, p1.ability_id, p1.trainer_id
        FROM Pokemon_1 p1, Pokemon_3 p3 
        WHERE p1.total_XP = p3.total_XP
        ORDER BY p1.pokedex, p1.pokemon_id
    `);
}

async function fetchLearnedMovesFromDb() {
    return await fetchFromDb(`
        SELECT lm.pokedex, lm.pokemon_id, lm.move_id, p.name as pokemon_name, m.name as move_name
        FROM Pokemon_Has_Learned_Move lm, Pokemon_1 p, Move m
        WHERE lm.pokedex = p.pokedex AND lm.pokemon_id = p.pokemon_id AND lm.move_id = m.move_id
        ORDER BY lm.pokedex, lm.pokemon_id, lm.move_id
    `);
}

async function fetchSpeciesFromDb() {
    return await fetchFromDb('SELECT * FROM Species ORDER BY pokedex');
}

async function fetchMovesFromDb() {
    return await fetchFromDb('SELECT move_id, name, type_name, power, pp, accuracy FROM Move ORDER BY move_id');
}

async function fetchAbilitiesFromDb() {
    return await fetchFromDb('SELECT * FROM Ability ORDER BY ability_id');
}

async function fetchNaturesFromDb() {
    return await fetchFromDb('SELECT * FROM Pokemon_2 ORDER BY nature');
}

// INSERT FUNCTIONS
async function insertTrainer(trainerId, name, locationName) {
    return await withOracleDB(async (connection) => {
        // Server-side validation
        const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });
        const validName = validateString(name, 'Name', { required: true, maxLength: 255, pattern: /^[a-zA-Z0-9\s\-\.']+$/ });
        const validLocation = validateString(locationName, 'Location', { maxLength: 40, allowNull: true });

        const result = await connection.execute(
            `INSERT INTO Trainer (trainer_id, name, location_name) VALUES (:trainerId, :name, :locationName)`,
            [validTrainerId, validName, validLocation],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error inserting trainer:', err);
        return false;
    });
}

async function insertPlayer(trainerId, money) {
    return await withOracleDB(async (connection) => {
        const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });
        const validMoney = validateInteger(money, 'Money', { required: true, min: 0 });

        const result = await connection.execute(
            `INSERT INTO Player (trainer_id, money) VALUES (:trainerId, :money)`,
            [validTrainerId, validMoney],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error inserting player:', err);
        return false;
    });
}

async function insertPokemon(pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) {
    return await withOracleDB(async (connection) => {
        const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
        const validPokemonId = validateInteger(pokemon_id, 'Pokemon ID', { required: true, min: 1 });
        const validName = validateString(name, 'Pokemon Name', { required: true, maxLength: 20, pattern: /^[a-zA-Z0-9\s\-\.']+$/ });
        const validXP = validateInteger(total_XP, 'Total XP', { required: true, min: 0 });
        const validNature = validateNature(nature);
        const validHPIV = validateInteger(HP_IV, 'HP IV', { required: true, min: 0, max: 31 });
        const validAttackIV = validateInteger(attack_IV, 'Attack IV', { required: true, min: 0, max: 31 });
        const validDefenseIV = validateInteger(defense_IV, 'Defense IV', { required: true, min: 0, max: 31 });
        const validSpeedIV = validateInteger(speed_IV, 'Speed IV', { required: true, min: 0, max: 31 });
        const validAbilityId = validateInteger(ability_id, 'Ability ID', { required: true, min: 1 });
        const validTrainerId = validateInteger(trainer_id, 'Trainer ID', { min: 1, allowNull: true });

        const result = await connection.execute(
            `INSERT INTO Pokemon_1 
                (pokedex, pokemon_id, name, total_XP, nature, HP_IV, attack_IV, defense_IV, speed_IV, ability_id, trainer_id) 
            VALUES 
                (:pokedex, :pokemon_id, :name, :total_XP, :nature, :HP_IV, :attack_IV, :defense_IV, :speed_IV, :ability_id, :trainer_id)`,
            [validPokedex, validPokemonId, validName, validXP, validNature, validHPIV, validAttackIV, validDefenseIV, validSpeedIV, validAbilityId, validTrainerId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error inserting Pokemon:', err);
        return false;
    });
}

async function insertPokemonHasLearnedMove(pokedex, pokemon_id, move_id) {
    return await withOracleDB(async (connection) => {
        const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
        const validPokemonId = validateInteger(pokemon_id, 'Pokemon ID', { required: true, min: 1 });
        const validMoveId = validateInteger(move_id, 'Move ID', { required: true, min: 1 });

        const result = await connection.execute(
            `INSERT INTO Pokemon_Has_Learned_Move (pokedex, pokemon_id, move_id) VALUES (:pokedex, :pokemon_id, :move_id)`,
            [validPokedex, validPokemonId, validMoveId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error inserting Pokemon_Has_Learned_Move:', err);
        return false;
    });
}

// DELETE FUNCTIONS
async function deleteTrainer(trainerId) {
    return await withOracleDB(async (connection) => {
        const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });

        const result = await connection.execute(
            `DELETE FROM Trainer WHERE trainer_id = :trainerId`,
            [validTrainerId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error deleting trainer:', trainerId, err);
        return false;
    });
}

async function deletePokemon(pokedex, pokemon_id) {
    return await withOracleDB(async (connection) => {
        const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
        const validPokemonId = validateInteger(pokemon_id, 'Pokemon ID', { required: true, min: 1 });

        const result = await connection.execute(
            `DELETE FROM Pokemon_1 WHERE pokedex = :pokedex AND pokemon_id = :pokemon_id`,
            [validPokedex, validPokemonId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error deleting Pokemon:', err);
        return false;
    });
}

async function deletePokemonHasLearnedMove(pokedex, pokemon_id, move_id) {
    return await withOracleDB(async (connection) => {
        const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
        const validPokemonId = validateInteger(pokemon_id, 'Pokemon ID', { required: true, min: 1 });
        const validMoveId = validateInteger(move_id, 'Move ID', { required: true, min: 1 });

        const result = await connection.execute(
            `DELETE FROM Pokemon_Has_Learned_Move WHERE pokedex = :pokedex AND pokemon_id = :pokemon_id AND move_id = :move_id`,
            [validPokedex, validPokemonId, validMoveId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((err) => {
        console.error('Error deleting Pokemon_Has_Learned_Move:', err);
        return false;
    });
}

// UPDATE FUNCTIONS
async function updateTrainer(trainerId, updates) {
    const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });

    if (!(await validateTrainerExists(validTrainerId))) {
        throw new Error('Trainer not found');
    }

    const validFields = ['name', 'location_name'];
    return await updateEntity('TRAINER', 'trainer_id', validTrainerId, updates, validFields);
}

async function updatePlayer(trainerId, updates) {
    const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });
    const validFields = ['money'];
    return await updateEntity('PLAYER', 'trainer_id', validTrainerId, updates, validFields);
}

async function updatePokemon(pokedex, pokemonId, updates) {
    const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
    const validPokemonId = validateInteger(pokemonId, 'Pokemon ID', { required: true, min: 1 });

    if (!(await validatePokemonExists(validPokedex, validPokemonId))) {
        throw new Error('Pokemon not found');
    }

    if (updates.ability_id !== undefined) {
        const validAbilityId = validateInteger(updates.ability_id, 'Ability ID', { required: true, min: 1 });
        updates.ability_id = validAbilityId;

        const abilityExists = await withOracleDB(async (connection) => {
            const result = await connection.execute(
                'SELECT 1 FROM Ability WHERE ability_id = :abilityId',
                [validAbilityId]
            );
            return result.rows.length > 0;
        });

        if (!abilityExists) {
            throw new Error('Ability ID does not exist');
        }
    }

    if (updates.trainer_id !== undefined && updates.trainer_id !== null) {
        const validTrainerId = validateInteger(updates.trainer_id, 'Trainer ID', { required: true, min: 1 });
        updates.trainer_id = validTrainerId;

        const trainerExists = await validateTrainerExists(validTrainerId);
        if (!trainerExists) {
            throw new Error('Trainer ID does not exist');
        }
    }

    // Validate other fields
    if (updates.name !== undefined) {
        updates.name = validateString(updates.name, 'Pokemon Name', { required: true, maxLength: 20, pattern: /^[a-zA-Z0-9\s\-\.']+$/ });
    }
    if (updates.total_XP !== undefined) {
        updates.total_XP = validateInteger(updates.total_XP, 'Total XP', { required: true, min: 0 });
    }
    if (updates.nature !== undefined) {
        updates.nature = validateNature(updates.nature);
    }
    if (updates.HP_IV !== undefined) {
        updates.HP_IV = validateInteger(updates.HP_IV, 'HP IV', { required: true, min: 0, max: 31 });
    }
    if (updates.attack_IV !== undefined) {
        updates.attack_IV = validateInteger(updates.attack_IV, 'Attack IV', { required: true, min: 0, max: 31 });
    }
    if (updates.defense_IV !== undefined) {
        updates.defense_IV = validateInteger(updates.defense_IV, 'Defense IV', { required: true, min: 0, max: 31 });
    }
    if (updates.speed_IV !== undefined) {
        updates.speed_IV = validateInteger(updates.speed_IV, 'Speed IV', { required: true, min: 0, max: 31 });
    }

    const validFields = ['name', 'total_XP', 'nature', 'HP_IV', 'attack_IV', 'defense_IV', 'speed_IV', 'ability_id', 'trainer_id'];
    return await updateEntity('POKEMON_1', ['pokedex', 'pokemon_id'], [validPokedex, validPokemonId], updates, validFields);
}

async function updatePokemonHasLearnedMove(pokedex, pokemonId, oldMoveId, newMoveId) {
    const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
    const validPokemonId = validateInteger(pokemonId, 'Pokemon ID', { required: true, min: 1 });
    const validOldMoveId = validateInteger(oldMoveId, 'Old Move ID', { required: true, min: 1 });
    const validNewMoveId = validateInteger(newMoveId, 'New Move ID', { required: true, min: 1 });

    if (!(await validatePokemonExists(validPokedex, validPokemonId))) {
        throw new Error('Pokemon not found');
    }

    const oldMoveExists = await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT 1 FROM Pokemon_Has_Learned_Move WHERE pokedex = :pokedex AND pokemon_id = :pokemonId AND move_id = :moveId',
            [validPokedex, validPokemonId, validOldMoveId]
        );
        return result.rows.length > 0;
    });

    if (!oldMoveExists) {
        throw new Error('Pokemon does not know the specified move');
    }

    const newMoveExists = await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT 1 FROM Move WHERE move_id = :moveId',
            [validNewMoveId]
        );
        return result.rows.length > 0;
    });

    if (!newMoveExists) {
        throw new Error('New move ID does not exist');
    }

    const canLearnMove = await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT 1 FROM Species_Can_Learn_Move WHERE pokedex = :pokedex AND move_id = :moveId',
            [validPokedex, validNewMoveId]
        );
        return result.rows.length > 0;
    });

    if (!canLearnMove) {
        throw new Error('This Pokemon species cannot learn the specified move');
    }

    const alreadyKnowsMove = await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT * FROM Pokemon_Has_Learned_Move WHERE pokedex = :pokedex AND pokemon_id = :pokemonId AND move_id = :moveId',
            [validPokedex, validPokemonId, validNewMoveId]
        );
        return result.rows.length > 0;
    });

    if (alreadyKnowsMove) {
        throw new Error('Pokemon already knows this move');
    }

    return await withOracleDB(async (connection) => {
        const result = await connection.execute(`
            UPDATE Pokemon_Has_Learned_Move 
            SET move_id = :newMoveId 
            WHERE pokedex = :pokedex AND pokemon_id = :pokemonId AND move_id = :oldMoveId
            `,
            [validNewMoveId, validPokedex, validPokemonId, validOldMoveId],
            { autoCommit: true }
        );

        if (result.rowsAffected === 0) {
            throw new Error('No records were updated - move not found');
        }

        return true;
    });
}

// UPDATE HELPERS
async function validateTrainerExists(trainerId) {
    const validTrainerId = validateInteger(trainerId, 'Trainer ID', { required: true, min: 1 });

    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT 1 FROM Trainer WHERE trainer_id = :id',
            [validTrainerId]
        );
        return result.rows.length > 0;
    });
}

async function validatePokemonExists(pokedex, pokemonId) {
    const validPokedex = validateInteger(pokedex, 'Pokedex', { required: true, min: 1 });
    const validPokemonId = validateInteger(pokemonId, 'Pokemon ID', { required: true, min: 1 });

    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            'SELECT 1 FROM Pokemon_1 WHERE pokedex = :pokedex AND pokemon_id = :pokemonId',
            [validPokedex, validPokemonId]
        );
        return result.rows.length > 0;
    });
}

async function updateEntity(table, idField, idValue, updates, allowedFields) {
    const validTable = validateTableName(table);

    const filteredUpdates = {};
    for (const [key, value] of Object.entries(updates)) {
        if (allowedFields.includes(key) && value !== undefined) {
            const validKey = validateColumnName(validTable, key);

            if (key === 'name' || key === 'location_name') {
                filteredUpdates[validKey] = validateString(value, key, { maxLength: key === 'name' ? 255 : 40 });
            } else if (key === 'money' || key.includes('_IV') || key === 'total_XP' || key === 'ability_id' || key === 'trainer_id') {
                filteredUpdates[validKey] = validateInteger(value, key, { min: 0 });
            } else if (key === 'nature') {
                filteredUpdates[validKey] = validateNature(value);
            } else {
                filteredUpdates[validKey] = value;
            }
        }
    }

    if (Object.keys(filteredUpdates).length === 0) {
        throw new Error('No valid fields provided for update');
    }

    const setClauses = [];
    const bindVars = {};
    let i = 1;

    for (const [key, value] of Object.entries(filteredUpdates)) {
        setClauses.push(`${key} = :val${i}`);
        bindVars[`val${i}`] = value;
        i++;
    }

    let whereClause;
    if (Array.isArray(idField)) {
        const validIdFields = idField.map(field => validateColumnName(validTable, field));
        whereClause = validIdFields.map((field, index) => `${field} = :id${index}`).join(' AND ');
        validIdFields.forEach((field, index) => {
            bindVars[`id${index}`] = Array.isArray(idValue) ? idValue[index] : idValue;
        });
    } else {
        const validIdField = validateColumnName(validTable, idField);
        whereClause = `${validIdField} = :id`;
        bindVars.id = idValue;
    }

    const query = `UPDATE ${validTable} SET ${setClauses.join(', ')} WHERE ${whereClause}`;

    return await withOracleDB(async (connection) => {
        const result = await connection.execute(query, bindVars, { autoCommit: true });

        if (result.rowsAffected === 0) {
            throw new Error('No records were updated - record not found');
        }

        return true;
    });
}

// SELECTION
async function executeSelectionQuery(conditions) {
    return await withOracleDB(async (connection) => {
        let query = `
            SELECT p1.pokedex, p1.pokemon_id, p1.name, p3.pokemon_level, p1.nature,
                   p1.HP_IV, p1.attack_IV, p1.defense_IV, p1.speed_IV, p1.ability_id, p1.trainer_id
            FROM Pokemon_1 p1, Pokemon_3 p3
            WHERE p1.total_XP = p3.total_XP
        `;
        const bindVars = {};
        let bindIndex = 1;

        if (conditions && conditions.length > 0) {
            query += " AND (";
            for (let i = 0; i < conditions.length; i++) {
                const condition = conditions[i];

                const validAttribute = validatePokemonAttribute(condition.attribute);
                const validOperator = validateOperator(condition.operator);
                const validLogical = (i > 0) ? validateLogicalOperator(conditions[i - 1].logical) : null;

                if (i > 0) {
                    query += ` ${validLogical} `;
                }

                const bindName = `val${bindIndex++}`;
                query += `${validAttribute} ${validOperator} :${bindName}`;
                bindVars[bindName] = condition.value;
            }
        }

        query += ") ORDER BY p1.pokedex, p1.pokemon_id";

        const result = await connection.execute(query, bindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error during selection query:', err);
        throw err;
    });
}

// PROJECTION
async function fetchTableNames() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            `SELECT table_name FROM user_tables ORDER BY table_name`
        );

        const allowedTables = [
            'TRAINER', 'PLAYER', 'POKEMON_1', 'POKEMON_2', 'POKEMON_3',
            'SPECIES', 'MOVE', 'ABILITY', 'TYPE', 'LOCATION', 'BADGE',
            'EGG_GROUP', 'ITEM_1', 'ITEM_2', 'GYM_LEADER_1', 'GYM_LEADER_2',
            'SPECIES_EVOLVES_INTO', 'POKEMON_HAS_LEARNED_MOVE', 'SPECIES_HAS_TYPE',
            'SPECIES_CAN_LEARN_MOVE', 'SPECIES_CAN_HAVE_ABILITY', 'SPECIES_LOCATED_IN',
            'SPECIES_BELONGS_TO_EGG_GROUP', 'PLAYER_OWNS_BADGE'
        ];

        return result.rows.map(row => row[0]).filter(table => allowedTables.includes(table));
    }).catch((err) => {
        console.error('Error fetching table names:', err);
        throw err;
    });
}

async function fetchColumnNames(tableName) {
    return await withOracleDB(async (connection) => {

        const validTableName = validateTableName(tableName);

        const result = await connection.execute(
            `SELECT column_name FROM user_tab_columns WHERE table_name = :tableName ORDER BY column_name`,
            [validTableName]
        );
        return result.rows.map(row => row[0]);
    }).catch((err) => {
        console.error(`Error fetching columns for table ${tableName}:`, err);
        throw err;
    });
}

async function executeProjectionQuery(table, attributes) {
    return await withOracleDB(async (connection) => {

        const validTableName = validateTableName(table);

        if (!attributes || attributes.length === 0) {
            throw new Error('No attributes provided');
        }

        const validAttributes = attributes.map(attr => validateColumnName(validTableName, attr));

        const query = `SELECT ${validAttributes.join(', ')} FROM ${validTableName}`;
        const result = await connection.execute(query);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing projection query:', err);
        throw err;
    });
}

// JOIN QUERIES
async function executeSpeciesLocationJoin(locationName = null) {
    return await withOracleDB(async (connection) => {
        let query = `
            SELECT s.pokedex, s.name as species_name, s.description, l.name as location_name, l.climate, l.terrain_type
            FROM Species s, Species_Located_In sli, Location l
            WHERE s.pokedex = sli.pokedex AND sli.location_name = l.name
        `;
        const bindVars = {};

        if (locationName) {

            const validLocation = validateString(locationName, 'Location Name', { required: true, maxLength: 40 });
            query += " AND l.name = :locationName";
            bindVars.locationName = validLocation;
        }

        query += " ORDER BY s.pokedex, l.name";

        const result = await connection.execute(query, bindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing species location join:', err);
        throw err;
    });
}

async function fetchLocationsForJoin() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute('SELECT DISTINCT name FROM Location ORDER BY name');
        return result.rows.map(row => row[0]);
    }).catch((err) => {
        console.error('Error fetching locations:', err);
        throw err;
    });
}

// AGGREGATION WITH GROUP BY
async function executeDefenseIVGroupBy(minDefenseIV = null) {
    return await withOracleDB(async (connection) => {
        let query = `
            SELECT t.trainer_id, t.name as trainer_name, p.name as pokemon_name, p.defense_IV
            FROM Pokemon_1 p, Trainer t
            WHERE p.trainer_id = t.trainer_id
        `;
        const bindVars = {};

        if (minDefenseIV !== null) {
            const validMinDefenseIV = validateInteger(minDefenseIV, 'Minimum Defense IV', { min: 0, max: 31 });
            query += " AND p.defense_IV >= :minDefenseIV";
            bindVars.minDefenseIV = validMinDefenseIV;
        }

        query += " ORDER BY t.trainer_id, p.defense_IV DESC";

        const result = await connection.execute(query, bindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing defense IV group by:', err);
        throw err;
    });
}

async function executeTrainerPokemonCount() {
    return await withOracleDB(async (connection) => {
        const query = `
            SELECT t.trainer_id, t.name as trainer_name, COUNT(p.pokemon_id) as pokemon_count,
                   AVG(p.defense_IV) as avg_defense_iv, MAX(p.defense_IV) as max_defense_iv
            FROM Trainer t
            LEFT JOIN Pokemon_1 p ON t.trainer_id = p.trainer_id
            GROUP BY t.trainer_id, t.name
            ORDER BY pokemon_count DESC, t.trainer_id
        `;

        const result = await connection.execute(query);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing trainer pokemon count:', err);
        throw err;
    });
}

// AGGREGATION WITH HAVING
async function executeHighestXPHaving(minPokemonCount = 2) {
    return await withOracleDB(async (connection) => {
        const validMinCount = validateInteger(minPokemonCount, 'Minimum Pokemon Count', { required: true, min: 1, max: 20 });

        const query = `
            SELECT t.trainer_id, t.name as trainer_name, MAX(p.total_XP) as highest_xp, COUNT(p.pokemon_id) as pokemon_count
            FROM Trainer t, Pokemon_1 p 
            WHERE t.trainer_id = p.trainer_id
            GROUP BY t.trainer_id, t.name
            HAVING COUNT(p.pokemon_id) >= :minPokemonCount
            ORDER BY highest_xp DESC
        `;

        const result = await connection.execute(query, { minPokemonCount: validMinCount });
        return result.rows;
    }).catch((err) => {
        console.error('Error executing highest XP having query:', err);
        throw err;
    });
}

async function executeTrainersWithMultiplePokemon(minXP = null) {
    return await withOracleDB(async (connection) => {
        let query = `
            SELECT t.trainer_id, t.name as trainer_name, 
                   COUNT(p.pokemon_id) as pokemon_count,
                   AVG(p.total_XP) as avg_xp,
                   MAX(p.total_XP) as max_xp,
                   MIN(p.total_XP) as min_xp
            FROM Trainer t, Pokemon_1 p
            WHERE t.trainer_id = p.trainer_id
        `;
        const bindVars = { minPokemonCount: 2 };

        if (minXP !== null) {
            const validMinXP = validateInteger(minXP, 'Minimum XP', { min: 0 });
            query += " AND p.total_XP >= :minXP";
            bindVars.minXP = validMinXP;
        }

        query += `
            GROUP BY t.trainer_id, t.name
            HAVING COUNT(p.pokemon_id) >= :minPokemonCount
            ORDER BY pokemon_count DESC, max_xp DESC
        `;

        const result = await connection.execute(query, bindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing trainers with multiple pokemon:', err);
        throw err;
    });
}

// NESTED AGGREGATION WITH GROUP BY
async function executeNestedAggregation() {
    return await withOracleDB(async (connection) => {
        const query = `
            SELECT t.trainer_id, t.name as trainer_name, 
                   COUNT(p.pokemon_id) as pokemon_count,
                   AVG(p.total_XP) as avg_xp
            FROM Trainer t, Pokemon_1 p
            WHERE t.trainer_id = p.trainer_id
            GROUP BY t.trainer_id, t.name
            HAVING AVG(p.total_XP) > (
                SELECT AVG(total_XP) 
                FROM Pokemon_1
            )
            ORDER BY avg_xp DESC
        `;

        const result = await connection.execute(query);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing nested aggregation:', err);
        throw err;
    });
}

async function executeTrainersAboveAverageXP() {
    return await withOracleDB(async (connection) => {
        const query = `
            SELECT trainer_stats.trainer_id, 
                   trainer_stats.trainer_name,
                   trainer_stats.pokemon_count,
                   trainer_stats.avg_trainer_xp,
                   global_stats.overall_avg_xp
            FROM (
                SELECT t.trainer_id, t.name as trainer_name, 
                       COUNT(p.pokemon_id) as pokemon_count,
                       AVG(p.total_XP) as avg_trainer_xp
                FROM Trainer t, Pokemon_1 p
                WHERE t.trainer_id = p.trainer_id
                GROUP BY t.trainer_id, t.name
            ) trainer_stats, (
                SELECT AVG(total_XP) as overall_avg_xp
                FROM Pokemon_1
            ) global_stats
            WHERE trainer_stats.avg_trainer_xp > global_stats.overall_avg_xp
            ORDER BY trainer_stats.avg_trainer_xp DESC
        `;

        const result = await connection.execute(query);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing trainers above average XP:', err);
        throw err;
    });
}

// DIVISION

async function executeSpeciesWithAllTypes(typeNames = []) {
    return await withOracleDB(async (connection) => {
        if (!typeNames || typeNames.length === 0) {

            const query = `
                SELECT s.pokedex, s.name as species_name, 
                       LISTAGG(sht.type_name, ', ') WITHIN GROUP (ORDER BY sht.type_name) as types
                FROM Species s, Species_Has_Type sht
                WHERE s.pokedex = sht.pokedex
                GROUP BY s.pokedex, s.name
                ORDER BY s.pokedex
            `;
            const result = await connection.execute(query);
            return result.rows;
        }

        const validTypes = [];
        const validTypeNames = ['Normal', 'Fire', 'Water', 'Electric', 'Grass', 'Ice', 'Fighting', 'Poison', 'Ground', 'Flying', 'Psychic', 'Bug', 'Rock', 'Ghost', 'Dragon', 'Dark', 'Steel', 'Fairy'];

        for (const typeName of typeNames) {
            const validatedType = validateString(typeName, 'Type Name', { required: true, maxLength: 20 });
            if (!validTypeNames.includes(validatedType)) {
                throw new Error(`Invalid type name: ${validatedType}`);
            }
            validTypes.push(validatedType);
        }

        const typeCount = validTypes.length;
        const typeBindVars = {};
        const typeConditions = validTypes.map((type, index) => {
            const bindName = `type${index}`;
            typeBindVars[bindName] = type;
            return `:${bindName}`;
        }).join(', ');

        const query = `
            SELECT s.pokedex, s.name as species_name,
                   LISTAGG(sht.type_name, ', ') WITHIN GROUP (ORDER BY sht.type_name) as types
            FROM Species s, Species_Has_Type sht
            WHERE s.pokedex = sht.pokedex
            AND s.pokedex IN (
                SELECT sht2.pokedex
                FROM Species_Has_Type sht2
                WHERE sht2.type_name IN (${typeConditions})
                GROUP BY sht2.pokedex
                HAVING COUNT(DISTINCT sht2.type_name) = :typeCount
            )
            GROUP BY s.pokedex, s.name
            ORDER BY s.pokedex
        `;

        typeBindVars.typeCount = typeCount;
        const result = await connection.execute(query, typeBindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing species with all types:', err);
        throw err;
    });
}

async function fetchAllTypes() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute('SELECT name FROM Type ORDER BY name');
        return result.rows.map(row => row[0]);
    }).catch((err) => {
        console.error('Error fetching types:', err);
        throw err;
    });
}

async function executeSpeciesByTypeCount(exactTypeCount = null) {
    return await withOracleDB(async (connection) => {
        let query = `
            SELECT s.pokedex, s.name as species_name, 
                   COUNT(sht.type_name) as type_count,
                   LISTAGG(sht.type_name, ', ') WITHIN GROUP (ORDER BY sht.type_name) as types
            FROM Species s, Species_Has_Type sht
            WHERE s.pokedex = sht.pokedex
            GROUP BY s.pokedex, s.name
        `;
        const bindVars = {};

        if (exactTypeCount !== null) {
            const validTypeCount = validateInteger(exactTypeCount, 'Exact Type Count', { min: 1, max: 3 });
            query += " HAVING COUNT(sht.type_name) = :exactTypeCount";
            bindVars.exactTypeCount = validTypeCount;
        }

        query += " ORDER BY type_count DESC, s.pokedex";

        const result = await connection.execute(query, bindVars);
        return result.rows;
    }).catch((err) => {
        console.error('Error executing species by type count:', err);
        throw err;
    });
}

// EXPORTS
module.exports = {
    // System functions
    testOracleConnection,
    initiatePokemonDB,

    // Fetch functions
    fetchTrainersFromDb,
    fetchPlayersFromDb,
    fetchPokemonFromDb,
    fetchLearnedMovesFromDb,
    fetchSpeciesFromDb,
    fetchMovesFromDb,
    fetchAbilitiesFromDb,
    fetchNaturesFromDb,

    // Insert functions
    insertTrainer,
    insertPlayer,
    insertPokemon,
    insertPokemonHasLearnedMove,

    // Delete functions
    deleteTrainer,
    deletePokemon,
    deletePokemonHasLearnedMove,

    // Update functions
    updateTrainer,
    updatePlayer,
    updatePokemon,
    updatePokemonHasLearnedMove,
    updateEntity,

    // Selection
    executeSelectionQuery,

    // Projection
    fetchTableNames,
    fetchColumnNames,
    executeProjectionQuery,

    // Join
    executeSpeciesLocationJoin,
    fetchLocationsForJoin,

    // Aggregation with GROUP BY
    executeDefenseIVGroupBy,
    executeTrainerPokemonCount,

    // Aggregation with HAVING
    executeHighestXPHaving,
    executeTrainersWithMultiplePokemon,

    // Nested aggregation with GROUP BY
    executeNestedAggregation,
    executeTrainersAboveAverageXP,

    // Division
    executeSpeciesWithAllTypes,
    fetchAllTypes,
    executeSpeciesByTypeCount
};
</file>

<file path="frontend/public/scripts.js">
/*
 * Pokemon Database Frontend JavaScript
 * Handles all form submissions, data display, and table refreshing
 */

// SYSTEM FUNCTIONS
// This function checks the database connection and updates its status on the frontend.
async function checkDbConnection() {
    const statusElem = document.getElementById('dbStatus');
    const loadingGifElem = document.getElementById('loadingGif');

    const response = await fetch('/check-db-connection', {
        method: "GET"
    });
    // Hide the loading GIF once the response is received.
    loadingGifElem.style.display = 'none';
    // Display the statusElem's text in the placeholder.
    statusElem.style.display = 'inline';

    response.text()
        .then((text) => {
            statusElem.textContent = text;
        })
        .catch((error) => {
            statusElem.textContent = 'connection timed out'; // Adjust error handling if required.
        });
}

// This function resets or initializes the database.
async function resetDatabase() {
    const response = await fetch("/initiate-database", {
        method: 'POST'
    });
    const responseData = await response.json();

    if (responseData.success) {
        const messageElement = document.getElementById('resetResultMsg');
        messageElement.textContent = "Pokemon database initiated successfully!";
        alert("Database reset successful!");

        setTimeout(refreshAllTables, 2000);
    } else {
        alert("Error initiating database!");
    }
}

// FETCH AND DISPLAY
async function fetchAndDisplayTrainers() {
    fetchAndDisplay('trainersTable', '/trainers');
}

async function fetchAndDisplayPlayers() {
    fetchAndDisplay('playersTable', '/players');
}

async function fetchAndDisplayPokemon() {
    fetchAndDisplay('pokemonTable', '/pokemon');
}

async function fetchAndDisplayLearnedMoves() {
    fetchAndDisplay('learnedMovesTable', '/learned-moves');
}

async function fetchAndDisplaySpecies() {
    fetchAndDisplay('speciesTable', '/species');
}

async function fetchAndDisplayMoves() {
    fetchAndDisplay('movesTable', '/moves');
}

async function fetchAndDisplayAbilities() {
    fetchAndDisplay('abilitiesTable', '/abilities');
}

async function fetchAndDisplayNatures() {
    fetchAndDisplay('naturesTable', '/natures');
}

// Fetches data from given table using given endpoint and displays it.
async function fetchAndDisplay(tableId, endpoint) {
    const tableElement = document.getElementById(tableId);
    const tableBody = tableElement.querySelector('tbody');

    const response = await fetch(endpoint, { method: 'GET' });
    const responseData = await response.json();
    const content = responseData.data;

    // Always clear old, already fetched data before new fetching process.
    if (tableBody) {
        tableBody.innerHTML = '';
    }

    content.forEach(tuple => {
        const row = tableBody.insertRow();
        tuple.forEach((field, index) => {
            const cell = row.insertCell(index);
            if (field || field === 0) {
                cell.textContent = field;
            } else {
                cell.textContent = 'NULL';
            };
        });
    });
}

// General function to refresh the displayed table data. 
// You can invoke this after any table-modifying operation to keep consistency.
function refreshAllTables() {
    fetchAndDisplayTrainers();
    fetchAndDisplayPlayers();
    fetchAndDisplayPokemon();
    fetchAndDisplayLearnedMoves();
    fetchAndDisplaySpecies();
    fetchAndDisplayMoves();
    fetchAndDisplayAbilities();
    fetchAndDisplayNatures();
}

// INSERT FUNCTIONS
// Inserts new records into each table.
async function insertTrainer(event) {
    event.preventDefault();

    const trainerIdValue = document.getElementById('insertTrainerId').value;
    const nameValue = document.getElementById('insertTrainerName').value;
    const locationValue = document.getElementById('insertTrainerLocation').value;

    const response = await fetch('/insert-trainer', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            trainerId: trainerIdValue,
            name: nameValue,
            locationName: locationValue || null
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('insertTrainerResultMsg');

    if (responseData.success) {
        alert("Trainer inserted successfully!");
        messageElement.textContent = "Trainer inserted successfully!";
        document.getElementById('insertTrainer').reset();
        refreshAllTables();
    } else {
        alert("Error inserting trainer! Check your input.");
        messageElement.textContent = "Error inserting trainer!";
    }
}

async function insertPlayer(event) {
    event.preventDefault();

    const trainerIdValue = document.getElementById('insertPlayerTrainerId').value;
    const moneyValue = document.getElementById('insertPlayerMoney').value;

    const response = await fetch('/insert-player', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            trainerId: trainerIdValue,
            money: moneyValue
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('insertPlayerResultMsg');

    if (responseData.success) {
        alert("Player inserted successfully!");
        messageElement.textContent = "Player inserted successfully!";
        document.getElementById('insertPlayer').reset();
        refreshAllTables();
    } else {
        alert("Error inserting player! Make sure trainer exists or player has not already been inserted.");
        messageElement.textContent = "Error inserting player!";
    }
}

async function insertPokemon(event) {
    event.preventDefault();

    const pokedexValue = document.getElementById('insertPokemonPokedex').value;
    const pokemonIdValue = document.getElementById('insertPokemonId').value;
    const nameValue = document.getElementById('insertPokemonName').value;
    const xpValue = document.getElementById('insertPokemonXP').value;
    const natureValue = document.getElementById('insertPokemonNature').value;
    const hpIvValue = document.getElementById('insertPokemonHPIV').value;
    const attackIvValue = document.getElementById('insertPokemonAttackIV').value;
    const defenseIvValue = document.getElementById('insertPokemonDefenseIV').value;
    const speedIvValue = document.getElementById('insertPokemonSpeedIV').value;
    const abilityIdValue = document.getElementById('insertPokemonAbilityId').value;
    const trainerIdValue = document.getElementById('insertPokemonTrainerId').value;

    const response = await fetch('/insert-pokemon', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            pokedex: pokedexValue,
            pokemon_id: pokemonIdValue,
            name: nameValue,
            total_XP: xpValue,
            nature: natureValue,
            HP_IV: hpIvValue,
            attack_IV: attackIvValue,
            defense_IV: defenseIvValue,
            speed_IV: speedIvValue,
            ability_id: abilityIdValue,
            trainer_id: trainerIdValue || null
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('insertPokemonResultMsg');

    if (responseData.success) {
        alert("Pokemon inserted successfully!");
        messageElement.textContent = "Pokemon inserted successfully!";
        document.getElementById('insertPokemon').reset();
        refreshAllTables();
    } else {
        alert("Error inserting Pokemon! Check your input values.");
        messageElement.textContent = "Error inserting Pokemon!";
    }
}

async function insertLearnedMove(event) {
    event.preventDefault();

    const pokedexValue = document.getElementById('insertLearnedMovePokedex').value;
    const pokemonIdValue = document.getElementById('insertLearnedMovePokemonId').value;
    const moveIdValue = document.getElementById('insertLearnedMoveId').value;

    const response = await fetch('/insert-learned-move', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            pokedex: pokedexValue,
            pokemon_id: pokemonIdValue,
            move_id: moveIdValue
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('insertLearnedMoveResultMsg');

    if (responseData.success) {
        alert("Move taught successfully!");
        messageElement.textContent = "Move taught successfully!";
        document.getElementById('insertLearnedMove').reset();
        refreshAllTables();
    } else {
        alert("Error teaching move! Make sure Pokemon and Move exist or Pokemon does not already know that move.");
        messageElement.textContent = "Error teaching move!";
    }
}

// DELETE FUNCTIONS
// Delete row based on primary key values
async function deleteTrainer(event) {
    event.preventDefault();

    const trainerIdValue = document.getElementById('deleteTrainerId').value;

    const response = await fetch('/delete-trainer', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ trainerId: trainerIdValue })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('deleteTrainerResultMsg');

    if (responseData.success) {
        alert("Trainer deleted successfully!");
        messageElement.textContent = "Trainer deleted successfully!";
        document.getElementById('deleteTrainer').reset();
        refreshAllTables();
    } else {
        alert("Error deleting trainer! Check your input.");
        messageElement.textContent = "Error deleting trainer!";
    }
}

async function deletePokemon(event) {
    event.preventDefault();

    const pokedexValue = document.getElementById('deletePokemonPokedex').value;
    const pokemonIdValue = document.getElementById('deletePokemonId').value;

    const response = await fetch('/delete-pokemon', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            pokedex: pokedexValue,
            pokemon_id: pokemonIdValue
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('deletePokemonResultMsg');

    if (responseData.success) {
        alert("Pokemon deleted successfully!");
        messageElement.textContent = "Pokemon deleted successfully!";
        document.getElementById('deletePokemon').reset();
        refreshAllTables();
    } else {
        alert("Error deleting Pokemon! Check your input.");
        messageElement.textContent = "Error deleting Pokemon!";
    }
}

async function deleteLearnedMove(event) {
    event.preventDefault();

    const pokedexValue = document.getElementById('deleteLearnedMovePokedex').value;
    const pokemonIdValue = document.getElementById('deleteLearnedMovePokemonId').value;
    const moveIdValue = document.getElementById('deleteLearnedMoveId').value;

    const response = await fetch('/delete-learned-move', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            pokedex: pokedexValue,
            pokemon_id: pokemonIdValue,
            move_id: moveIdValue
        })
    });

    const responseData = await response.json();
    const messageElement = document.getElementById('deleteLearnedMoveResultMsg');

    if (responseData.success) {
        alert("Move removed successfully!");
        messageElement.textContent = "Move removed successfully!";
        document.getElementById('deleteLearnedMove').reset();
        refreshAllTables();
    } else {
        alert("Error removing move! Check your input.");
        messageElement.textContent = "Error removing move!";
    }
}

// UPDATE FUNCTIONS
// Updates attributes in each table.
async function updateTrainer(event) {
    event.preventDefault();

    const trainerId = document.getElementById('updateTrainerId').value;
    const updates = {};

    const name = document.getElementById('updateTrainerName').value.trim();
    if (name) updates.name = name;

    const location = document.getElementById('updateTrainerLocation').value.trim();
    if (location) updates.location_name = location;

    try {
        const response = await fetch('/update-trainer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ trainerId, updates })
        });

        const responseData = await response.json();
        const messageElement = document.getElementById('updateTrainerResultMsg');

        messageElement.textContent = responseData.message;
        messageElement.style.color = responseData.success ? 'green' : 'red';

        if (responseData.success) {
            alert("Trainer updated successfully!");
            document.getElementById('updateTrainer').reset();
            refreshAllTables();
        } else {
            alert("Error updating Trainer! Check your input.");
        }
    } catch (error) {
        document.getElementById('updateTrainerResultMsg').textContent = 'Error: ' + error.message;
        document.getElementById('updateTrainerResultMsg').style.color = 'red';
    }
}

async function updatePlayer(event) {
    event.preventDefault();

    const trainerId = document.getElementById('updatePlayerTrainerId').value;
    const updates = {};

    const money = document.getElementById('updatePlayerMoney').value;
    if (money) {
        updates.money = money;
    }

    try {
        const response = await fetch('/update-player', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ trainerId, updates })
        });

        const responseData = await response.json();
        const messageElement = document.getElementById('updatePlayerResultMsg');

        if (responseData.success) {
            alert("Player updated successfully!");
            messageElement.textContent = "Player updated successfully!";
            document.getElementById('updatePlayer').reset();
            refreshAllTables();
        } else {
            alert("Error updating Player! " + responseData.message);
            messageElement.textContent = "Error updating Player: " + responseData.message;
        }
    } catch (error) {
        const messageElement = document.getElementById('updatePlayerResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

async function updatePokemon(event) {
    event.preventDefault();

    const pokedex = document.getElementById('updatePokemonPokedex').value;
    const pokemonId = document.getElementById('updatePokemonId').value;
    const updates = {};

    const fields = [
        { id: 'updatePokemonName', field: 'name', type: 'string' },
        { id: 'updatePokemonXP', field: 'total_XP', type: 'number' },
        { id: 'updatePokemonNature', field: 'nature', type: 'string' },
        { id: 'updatePokemonHPIV', field: 'HP_IV', type: 'number' },
        { id: 'updatePokemonAttackIV', field: 'attack_IV', type: 'number' },
        { id: 'updatePokemonDefenseIV', field: 'defense_IV', type: 'number' },
        { id: 'updatePokemonSpeedIV', field: 'speed_IV', type: 'number' },
        { id: 'updatePokemonAbilityId', field: 'ability_id', type: 'number' },
        { id: 'updatePokemonTrainerId', field: 'trainer_id', type: 'number' }
    ];

    fields.forEach(({ id, field, type }) => {
        const element = document.getElementById(id);
        if (element.value) {
            updates[field] = type === 'number' ? parseInt(element.value) : element.value;
        }
    });

    const messageElement = document.getElementById('updatePokemonResultMsg');
    try {
        const response = await fetch('/update-pokemon', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ pokedex, pokemonId, updates })
        });

        const responseData = await response.json();

        messageElement.textContent = responseData.message;
        messageElement.style.color = responseData.success ? 'green' : 'red';

        if (responseData.success) {
            alert("Pokemon updated successfully!");
            document.getElementById('updatePokemon').reset();
            refreshAllTables();
        } else {
            alert("Error updating Pokemon! Check your input.");
        }
    } catch (error) {
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

async function updateLearnedMove(event) {
    event.preventDefault();

    const pokedex = document.getElementById('updateLearnedMovePokedex').value;
    const pokemonId = document.getElementById('updateLearnedMovePokemonId').value;
    const oldMoveId = document.getElementById('updateLearnedMoveOldId').value;
    const newMoveId = document.getElementById('updateLearnedMoveNewId').value;

    try {
        const response = await fetch('/update-learned-move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                pokedex: parseInt(pokedex),
                pokemonId: parseInt(pokemonId),
                oldMoveId: parseInt(oldMoveId),
                newMoveId: parseInt(newMoveId)
            })
        });

        const responseData = await response.json();
        const messageElement = document.getElementById('updateLearnedMoveResultMsg');

        if (responseData.success) {
            alert("Move updated successfully!");
            messageElement.textContent = "Move updated successfully!";
            document.getElementById('updateLearnedMove').reset();
            refreshAllTables();
        } else {
            alert("Error updating move: " + responseData.message);
            messageElement.textContent = "Error: " + responseData.message;
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('updateLearnedMoveResultMsg');
        messageElement.textContent = 'A client-side error occurred: ' + error.message;
        messageElement.style.color = 'red';
    }
}

// SELECTION FUNCTIONS
function createConditionRow() {
    const conditionDiv = document.createElement('div');
    conditionDiv.className = 'condition-row';
    conditionDiv.style.marginBottom = '10px';

    const attributes = ['pokedex', 'pokemon_id', 'name', 'total_XP', 'nature', 'HP_IV', 'attack_IV', 'defense_IV', 'speed_IV', 'ability_id', 'trainer_id'];
    const attrSelect = document.createElement('select');
    attrSelect.className = 'attribute-select';
    attributes.forEach(attr => {
        const option = document.createElement('option');
        option.value = attr;
        option.textContent = attr;
        attrSelect.appendChild(option);
    });

    const operators = ['=', '!=', '>', '<', '>=', '<='];
    const opSelect = document.createElement('select');
    opSelect.className = 'operator-select';
    operators.forEach(op => {
        const option = document.createElement('option');
        option.value = op;
        option.textContent = op;
        opSelect.appendChild(option);
    });

    const valueInput = document.createElement('input');
    valueInput.type = 'text';
    valueInput.className = 'value-input';
    valueInput.placeholder = 'Enter value';

    const logicalSelect = document.createElement('select');
    logicalSelect.className = 'logical-select';
    logicalSelect.innerHTML = '<option value="AND">AND</option><option value="OR">OR</option>';
    logicalSelect.style.display = 'none';

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => {
        conditionDiv.remove();
        updateLogicalSelects();
    };

    conditionDiv.appendChild(attrSelect);
    conditionDiv.appendChild(document.createTextNode(' '));
    conditionDiv.appendChild(opSelect);
    conditionDiv.appendChild(document.createTextNode(' '));
    conditionDiv.appendChild(valueInput);
    conditionDiv.appendChild(document.createTextNode(' '));
    conditionDiv.appendChild(logicalSelect);
    conditionDiv.appendChild(document.createTextNode(' '));
    conditionDiv.appendChild(removeBtn);

    document.getElementById('conditionsContainer').appendChild(conditionDiv);
    updateLogicalSelects();
}

function updateLogicalSelects() {
    const conditions = document.querySelectorAll('.condition-row');
    conditions.forEach((condition, index) => {
        const logicalSelect = condition.querySelector('.logical-select');
        if (index < conditions.length - 1) {
            logicalSelect.style.display = 'inline';
        } else {
            logicalSelect.style.display = 'none';
        }
    });
}

async function handleSelectionQuery(event) {
    event.preventDefault();

    const conditions = [];
    const conditionRows = document.querySelectorAll('.condition-row');

    if (conditionRows.length === 0) {
        document.getElementById('selectionResultMsg').textContent = 'Please add at least one condition.';
        document.getElementById('selectionResultMsg').style.color = 'red';
        return;
    }

    conditionRows.forEach(row => {
        const attribute = row.querySelector('.attribute-select').value;
        const operator = row.querySelector('.operator-select').value;
        const value = row.querySelector('.value-input').value;
        const logical = row.querySelector('.logical-select').value;

        if (value.trim() === '') {
            return;
        }
        conditions.push({ attribute, operator, value, logical });
    });

    try {
        const response = await fetch('/selection-query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conditions })
        });

        const result = await response.json();
        const resultElement = document.getElementById('selectionResultMsg');

        if (result.success) {
            resultElement.textContent = `Found ${result.data.length} Pokemon.`;
            resultElement.style.color = 'green';
            displaySelectionResults(result.data);
        } else {
            resultElement.textContent = result.message || 'Error executing selection query!';
            resultElement.style.color = 'red';
        }
    } catch (error) {
        const resultElement = document.getElementById('selectionResultMsg');
        resultElement.textContent = 'Client-side error: ' + error.message;
        resultElement.style.color = 'red';
    }
}

function displaySelectionResults(data) {
    const tableElement = document.getElementById('selectionResultTable');
    const tableHead = tableElement.querySelector('thead');
    const tableBody = tableElement.querySelector('tbody');

    tableHead.innerHTML = '';
    tableBody.innerHTML = '';

    if (data.length === 0) return;

    const headers = ['Pokedex #', 'Pokemon ID', 'Name', 'Level', 'Nature', 'HP IV', 'Attack IV', 'Defense IV', 'Speed IV', 'Ability ID', 'Trainer ID'];
    const headerRow = tableHead.insertRow();
    headers.forEach(headerText => {
        const th = document.createElement('th');
        th.textContent = headerText;
        headerRow.appendChild(th);
    });

    data.forEach(rowData => {
        const tr = tableBody.insertRow();
        rowData.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// PROJECTION FUNCTIONS
async function populateTableDropdown() {
    try {
        const response = await fetch('/tables', { method: 'GET' });
        const responseData = await response.json();
        const tables = responseData.data;

        const tableSelect = document.getElementById('tableSelect');
        tableSelect.innerHTML = '<option value="" disabled selected>Select a table</option>';

        tables.forEach(table => {
            const option = document.createElement('option');
            option.value = table;
            option.textContent = table;
            tableSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Error fetching tables:', error);
        document.getElementById('projectionResultMsg').textContent = 'Error fetching tables: ' + error.message;
        document.getElementById('projectionResultMsg').style.color = 'red';
    }
}

async function populateAttributeCheckboxes() {
    const tableSelect = document.getElementById('tableSelect');
    const tableName = tableSelect.value;
    const attributeCheckboxes = document.getElementById('attributeCheckboxes');
    attributeCheckboxes.innerHTML = '';

    if (!tableName) return;

    try {
        const response = await fetch(`/columns/${tableName}`, { method: 'GET' });
        const responseData = await response.json();
        const columns = responseData.data;

        if (columns.length === 0) {
            attributeCheckboxes.innerHTML = '<p>No attributes available for this table.</p>';
            return;
        }

        attributeCheckboxes.style.display = 'flex';
        attributeCheckboxes.style.flexDirection = 'column';
        attributeCheckboxes.style.gap = '10px';

        columns.forEach(column => {
            const label = document.createElement('label');
            label.style.display = 'inline-flex';
            label.style.alignItems = 'center';
            label.style.gap = '8px';
            label.style.width = 'auto';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = column;
            checkbox.name = 'attributes';
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(column));
            attributeCheckboxes.appendChild(label);
        });
    } catch (error) {
        console.error('Error fetching columns:', error);
        document.getElementById('projectionResultMsg').textContent = 'Error fetching attributes: ' + error.message;
        document.getElementById('projectionResultMsg').style.color = 'red';
    }
}

async function runProjectionQuery(event) {
    event.preventDefault();

    const tableName = document.getElementById('tableSelect').value;
    const checkboxes = document.getElementsByName('attributes');
    const selectedAttributes = Array.from(checkboxes)
        .filter(checkbox => checkbox.checked)
        .map(checkbox => checkbox.value);

    if (!tableName || selectedAttributes.length === 0) {
        document.getElementById('projectionResultMsg').textContent = 'Please select a table and at least one attribute.';
        document.getElementById('projectionResultMsg').style.color = 'red';
        return;
    }

    try {
        const response = await fetch('/project', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ table: tableName, attributes: selectedAttributes })
        });

        const result = await response.json();
        const messageElement = document.getElementById('projectionResultMsg');

        if (result.success) {
            messageElement.textContent = 'Projection query executed successfully!';
            messageElement.style.color = 'green';
            displayProjectionResults(result.data, selectedAttributes);
        } else {
            messageElement.textContent = result.message || 'Error executing projection query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('projectionResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayProjectionResults(data, attributes) {
    const tableElement = document.getElementById('projectionResultTable');
    const tableHead = tableElement.querySelector('thead');
    const tableBody = tableElement.querySelector('tbody');

    tableHead.innerHTML = '';
    tableBody.innerHTML = '';

    const headerRow = tableHead.insertRow();
    attributes.forEach(attr => {
        const th = document.createElement('th');
        th.textContent = attr;
        headerRow.appendChild(th);
    });

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach((field, index) => {
            const td = tr.insertCell(index);
            if (field || field === 0) {
                td.textContent = field;
            } else {
                td.textContent = 'NULL';
            }
        });
    });
}

// JOIN FUNCTIONS
async function populateLocationDropdown() {
    try {
        const response = await fetch('/locations', { method: 'GET' });
        const responseData = await response.json();
        const locations = responseData.data;

        const locationSelect = document.getElementById('locationFilter');
        locationSelect.innerHTML = '<option value="">All Locations</option>';

        locations.forEach(location => {
            const option = document.createElement('option');
            option.value = location;
            option.textContent = location;
            locationSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Error fetching locations:', error);
    }
}

async function handleJoinQuery(event) {
    event.preventDefault();

    const location = document.getElementById('locationFilter').value;
    const url = location ? `/join/species-location?location=${encodeURIComponent(location)}` : '/join/species-location';

    try {
        const response = await fetch(url, { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('joinResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} species-location combinations.`;
            messageElement.style.color = 'green';
            displayJoinResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing join query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('joinResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayJoinResults(data) {
    const tableElement = document.getElementById('joinResultTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// AGGREGATION WITH GROUP BY FUNCTIONS
async function handleDefenseIVQuery(event) {
    event.preventDefault();

    const minDefenseIV = document.getElementById('minDefenseIV').value;
    const url = minDefenseIV ? `/aggregation/defense-iv?minDefenseIV=${minDefenseIV}` : '/aggregation/defense-iv';

    try {
        const response = await fetch(url, { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('defenseIVResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} Pokemon records.`;
            messageElement.style.color = 'green';
            displayDefenseIVResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing defense IV query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('defenseIVResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayDefenseIVResults(data) {
    const tableElement = document.getElementById('defenseIVTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

async function handleTrainerStats() {
    try {
        const response = await fetch('/aggregation/trainer-pokemon-count', { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('trainerStatsResultMsg');

        if (result.success) {
            messageElement.textContent = `Showing statistics for ${result.data.length} trainers.`;
            messageElement.style.color = 'green';
            displayTrainerStatsResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing trainer stats query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('trainerStatsResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayTrainerStatsResults(data) {
    const tableElement = document.getElementById('trainerStatsTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// AGGREGATION WITH HAVING FUNCTIONS
async function handleHighestXPQuery(event) {
    event.preventDefault();

    const minPokemonCount = document.getElementById('minPokemonCount').value;
    const url = `/aggregation/highest-xp-having?minPokemonCount=${minPokemonCount}`;

    try {
        const response = await fetch(url, { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('highestXPResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} trainers with at least ${minPokemonCount} Pokemon.`;
            messageElement.style.color = 'green';
            displayHighestXPResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing highest XP query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('highestXPResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayHighestXPResults(data) {
    const tableElement = document.getElementById('highestXPTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

async function handleMultiplePokemonQuery(event) {
    event.preventDefault();

    const minXP = document.getElementById('minXPFilter').value;
    const url = minXP ? `/aggregation/trainers-multiple-pokemon?minXP=${minXP}` : '/aggregation/trainers-multiple-pokemon';

    try {
        const response = await fetch(url, { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('multiplePokemonResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} trainers with multiple Pokemon.`;
            messageElement.style.color = 'green';
            displayMultiplePokemonResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing multiple Pokemon query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('multiplePokemonResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayMultiplePokemonResults(data) {
    const tableElement = document.getElementById('multiplePokemonTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// NESTED AGGREGATION FUNCTIONS
async function handleNestedAggregation() {
    try {
        const response = await fetch('/aggregation/nested', { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('nestedAggregationResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} trainers with above-average Pokemon XP.`;
            messageElement.style.color = 'green';
            displayNestedAggregationResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing nested aggregation query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('nestedAggregationResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayNestedAggregationResults(data) {
    const tableElement = document.getElementById('nestedAggregationTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

async function handleAboveAverageQuery() {
    try {
        const response = await fetch('/aggregation/trainers-above-average', { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('aboveAverageResultMsg');

        if (result.success) {
            messageElement.textContent = `Found ${result.data.length} trainers above global average.`;
            messageElement.style.color = 'green';
            displayAboveAverageResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing above average query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('aboveAverageResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayAboveAverageResults(data) {
    const tableElement = document.getElementById('aboveAverageTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// DIVISION FUNCTIONS
async function populateTypeCheckboxes() {
    try {
        const response = await fetch('/types', { method: 'GET' });
        const responseData = await response.json();
        const types = responseData.data;

        const typeContainer = document.getElementById('typeCheckboxes');
        typeContainer.innerHTML = '';

        typeContainer.style.display = 'flex';
        typeContainer.style.flexDirection = 'column';
        typeContainer.style.gap = '10px';

        types.forEach(type => {
            const label = document.createElement('label');
            label.style.display = 'inline-flex';
            label.style.alignItems = 'center';
            label.style.gap = '8px';
            label.style.width = 'auto';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = type;
            checkbox.name = 'types';

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(type));
            typeContainer.appendChild(label);
        });
    } catch (error) {
        console.error('Error fetching types:', error);
    }
}

async function handleDivisionQuery(event) {
    event.preventDefault();

    const checkboxes = document.getElementsByName('types');
    const selectedTypes = Array.from(checkboxes)
        .filter(checkbox => checkbox.checked)
        .map(checkbox => checkbox.value);

    try {
        const response = await fetch('/division/species-with-types', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ types: selectedTypes })
        });

        const result = await response.json();
        const messageElement = document.getElementById('divisionResultMsg');

        if (result.success) {
            if (selectedTypes.length === 0) {
                messageElement.textContent = `Showing all ${result.data.length} species and their types.`;
            } else {
                messageElement.textContent = `Found ${result.data.length} species with types: ${selectedTypes.join(', ')}.`;
            }
            messageElement.style.color = 'green';
            displayDivisionResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing division query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('divisionResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

async function showAllSpeciesTypes() {
    try {
        const response = await fetch('/division/species-with-types', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ types: [] })
        });

        const result = await response.json();
        const messageElement = document.getElementById('divisionResultMsg');

        if (result.success) {
            messageElement.textContent = `Showing all ${result.data.length} species and their types.`;
            messageElement.style.color = 'green';
            displayDivisionResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error showing all species types!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('divisionResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayDivisionResults(data) {
    const tableElement = document.getElementById('divisionResultTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

async function handleTypeCountQuery(event) {
    event.preventDefault();

    const exactTypeCount = document.getElementById('exactTypeCount').value;
    const url = exactTypeCount ? `/division/species-by-type-count?exactTypeCount=${exactTypeCount}` : '/division/species-by-type-count';

    try {
        const response = await fetch(url, { method: 'GET' });
        const result = await response.json();
        const messageElement = document.getElementById('typeCountResultMsg');

        if (result.success) {
            if (exactTypeCount) {
                messageElement.textContent = `Found ${result.data.length} species with exactly ${exactTypeCount} type(s).`;
            } else {
                messageElement.textContent = `Showing ${result.data.length} species grouped by type count.`;
            }
            messageElement.style.color = 'green';
            displayTypeCountResults(result.data);
        } else {
            messageElement.textContent = result.message || 'Error executing type count query!';
            messageElement.style.color = 'red';
        }
    } catch (error) {
        const messageElement = document.getElementById('typeCountResultMsg');
        messageElement.textContent = 'Error: ' + error.message;
        messageElement.style.color = 'red';
    }
}

function displayTypeCountResults(data) {
    const tableElement = document.getElementById('typeCountTable');
    const tableBody = tableElement.querySelector('tbody');

    tableBody.innerHTML = '';

    data.forEach(row => {
        const tr = tableBody.insertRow();
        row.forEach(field => {
            const td = tr.insertCell();
            td.textContent = field !== null ? field : 'NULL';
        });
    });
}

// EVENT LISTENERS AND INITIALIZATION
// Initializes the webpage functionalities.
// Add or remove event listeners based on the desired functionalities.
window.onload = function () {
    checkDbConnection();
    refreshAllTables();
    populateTableDropdown();
    populateLocationDropdown();
    populateTypeCheckboxes();

    // System events
    document.getElementById("resetDatabase").addEventListener("click", resetDatabase);

    // Insert events
    document.getElementById("insertTrainer").addEventListener("submit", insertTrainer);
    document.getElementById("insertPlayer").addEventListener("submit", insertPlayer);
    document.getElementById("insertPokemon").addEventListener("submit", insertPokemon);
    document.getElementById("insertLearnedMove").addEventListener("submit", insertLearnedMove);

    // Delete events
    document.getElementById("deleteTrainer").addEventListener("submit", deleteTrainer);
    document.getElementById("deletePokemon").addEventListener("submit", deletePokemon);
    document.getElementById("deleteLearnedMove").addEventListener("submit", deleteLearnedMove);

    // Update events
    document.getElementById('updateTrainer').addEventListener('submit', updateTrainer);
    document.getElementById('updatePlayer').addEventListener('submit', updatePlayer);
    document.getElementById('updatePokemon').addEventListener('submit', updatePokemon);
    document.getElementById('updateLearnedMove').addEventListener('submit', updateLearnedMove);

    // Selection events
    document.getElementById('addConditionBtn').addEventListener('click', createConditionRow);
    document.getElementById('selectionQueryForm').addEventListener('submit', handleSelectionQuery);

    // Projection events
    document.getElementById('tableSelect').addEventListener('change', populateAttributeCheckboxes);
    document.getElementById('projectionQuery').addEventListener('submit', runProjectionQuery);

    // Join events
    document.getElementById('joinQueryForm').addEventListener('submit', handleJoinQuery);

    // Aggregation events
    document.getElementById('defenseIVForm').addEventListener('submit', handleDefenseIVQuery);
    document.getElementById('trainerStatsBtn').addEventListener('click', handleTrainerStats);

    // Aggregation with HAVING events
    document.getElementById('highestXPForm').addEventListener('submit', handleHighestXPQuery);
    document.getElementById('multiplePokemonForm').addEventListener('submit', handleMultiplePokemonQuery);

    // Nested aggregation events
    document.getElementById('nestedAggregationBtn').addEventListener('click', handleNestedAggregation);
    document.getElementById('aboveAverageBtn').addEventListener('click', handleAboveAverageQuery);

    // Division events
    document.getElementById('divisionQueryForm').addEventListener('submit', handleDivisionQuery);
    document.getElementById('showAllSpeciesTypesBtn').addEventListener('click', showAllSpeciesTypes);
    document.getElementById('typeCountForm').addEventListener('submit', handleTypeCountQuery);
};
</file>

</files>
